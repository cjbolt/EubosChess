package eubos.board;

import java.util.Arrays;

import com.fluxchess.jcpi.models.IntChessman;
import com.fluxchess.jcpi.models.IntRank;

import eubos.main.EubosEngineMain;
import eubos.position.IAddMoves;
import eubos.position.Move;
import eubos.position.Position;

public abstract class Piece {
	public enum Colour { 
		white, black;
		
		public static Colour getOpposite( Colour arg ) { return (arg == white) ? black : white; }
		public static boolean isWhite( Colour arg ) { return arg == white; }
		public static boolean isBlack( Colour arg ) { return arg == black; }
	};
	
	// Note: Piece values below are not completely arbitrary, they must match Zobrist indexes
	public static final int NONE = 0x0;
	public static final int KING = 0x1;
	public static final int QUEEN = 0x2;
	public static final int ROOK = 0x3;
	public static final int BISHOP = 0x4;
	public static final int KNIGHT = 0x5;
	public static final int PAWN = 0x6;
	public static final int DONT_CARE = 0x7;
	
	public static final int BLACK = 0x8;
	public static final int COLOUR_BIT_SHIFT = 3;
	
	public static final int PIECE_NO_COLOUR_MASK = 0x7;
	public static final int PIECE_WHOLE_MASK = 0xf;

	public static final int WHITE_QUEEN = QUEEN;
	public static final int WHITE_BISHOP = BISHOP;
	public static final int WHITE_KING = KING;
	public static final int WHITE_KNIGHT = KNIGHT;
	public static final int WHITE_ROOK = ROOK;
	public static final int WHITE_PAWN = PAWN;
	
	public static final int BLACK_QUEEN = (BLACK|QUEEN);
	public static final int BLACK_BISHOP = (BLACK|BISHOP);
	public static final int BLACK_KING = (BLACK|KING);
	public static final int BLACK_KNIGHT = (BLACK|KNIGHT);
	public static final int BLACK_ROOK = (BLACK|ROOK);
	public static final int BLACK_PAWN = (BLACK|PAWN);
	
	public static boolean isPawn(int arg) { return (arg & PIECE_NO_COLOUR_MASK) == PAWN; }
	public static boolean isKing(int arg) { return (arg & PIECE_NO_COLOUR_MASK) == KING; }
	public static boolean isQueen(int arg) { return (arg & PIECE_NO_COLOUR_MASK) == QUEEN; }
	public static boolean isRook(int arg) { return (arg & PIECE_NO_COLOUR_MASK) == ROOK; }
	public static boolean isBishop(int arg) { return (arg & PIECE_NO_COLOUR_MASK) == BISHOP; }
	public static boolean isKnight(int arg) { return (arg & PIECE_NO_COLOUR_MASK) == KNIGHT; }
	
	public static boolean isOppositeColour(Colour ownColour, int toCheck) {
		if (EubosEngineMain.ENABLE_ASSERTS)
			assert (toCheck & PIECE_NO_COLOUR_MASK) != NONE;
		return Colour.isWhite(ownColour) ? isBlack(toCheck) : isWhite(toCheck);
	}
	public static boolean isOppositeColourOrNone(Colour ownColour, int toCheck) {
		boolean retVal = true;
		if (toCheck != Piece.NONE) {
			retVal = Colour.isWhite(ownColour) ? isBlack(toCheck) : isWhite(toCheck);
		}
		return retVal;
	}
	public static boolean isWhite(int arg) {
		return (arg&BLACK) == 0;
	}
	public static boolean isBlack(int arg) {
		return (arg&BLACK) == BLACK;
	}
	public static Colour getOpposite(int arg) {
		return isWhite(arg) ? Colour.black : Colour.white;
	} 
	
	public static final short MATERIAL_VALUE_KING = 4000;
	public static final short MATERIAL_VALUE_QUEEN = 900;
	public static final short MATERIAL_VALUE_ROOK = 490;
	public static final short MATERIAL_VALUE_BISHOP = 305;
	public static final short MATERIAL_VALUE_KNIGHT = 290;
	public static final short MATERIAL_VALUE_PAWN = 100;
	
	public static final short EG_MATERIAL_VALUE_KING = 4000;
	public static final short EG_MATERIAL_VALUE_QUEEN = 950;
	public static final short EG_MATERIAL_VALUE_ROOK = 520;
	public static final short EG_MATERIAL_VALUE_BISHOP = 305;
	public static final short EG_MATERIAL_VALUE_KNIGHT = 290;
	public static final short EG_MATERIAL_VALUE_PAWN = 130;
	
    public static final short [][] PIECE_TO_MATERIAL_LUT;
    static {
    	PIECE_TO_MATERIAL_LUT = new short [2][];
    	PIECE_TO_MATERIAL_LUT[0] = new short [] {0, MATERIAL_VALUE_KING, MATERIAL_VALUE_QUEEN, MATERIAL_VALUE_ROOK, 
    		MATERIAL_VALUE_BISHOP, MATERIAL_VALUE_KNIGHT, MATERIAL_VALUE_PAWN,
    		0, 0, 
    		-MATERIAL_VALUE_KING, -MATERIAL_VALUE_QUEEN, -MATERIAL_VALUE_ROOK, 
    		-MATERIAL_VALUE_BISHOP, -MATERIAL_VALUE_KNIGHT, -MATERIAL_VALUE_PAWN, 0};
		PIECE_TO_MATERIAL_LUT[1] = new short [] {
	    	0, EG_MATERIAL_VALUE_KING, EG_MATERIAL_VALUE_QUEEN, EG_MATERIAL_VALUE_ROOK, 
	    	EG_MATERIAL_VALUE_BISHOP, EG_MATERIAL_VALUE_KNIGHT, EG_MATERIAL_VALUE_PAWN,
			0, 0, 
			-EG_MATERIAL_VALUE_KING, -EG_MATERIAL_VALUE_QUEEN, -EG_MATERIAL_VALUE_ROOK, 
			-EG_MATERIAL_VALUE_BISHOP, -EG_MATERIAL_VALUE_KNIGHT, -EG_MATERIAL_VALUE_PAWN, 0};
	}
    
    public static final int [] PIECE_PHASE = {0, 0, 640, 320, 192, 192, 0, 0,
    		                                  0, 0, 640, 320, 192, 192, 0, 0};
	
	static final byte[] PAWN_WHITE_WEIGHTINGS;
    static {
    	PAWN_WHITE_WEIGHTINGS = new byte[128];
        PAWN_WHITE_WEIGHTINGS[Position.a1] = 0; PAWN_WHITE_WEIGHTINGS[Position.b1] = 0; PAWN_WHITE_WEIGHTINGS[Position.c1] = 0; PAWN_WHITE_WEIGHTINGS[Position.d1] = 0; PAWN_WHITE_WEIGHTINGS[Position.e1] = 0; PAWN_WHITE_WEIGHTINGS[Position.f1] = 0; PAWN_WHITE_WEIGHTINGS[Position.g1] = 0; PAWN_WHITE_WEIGHTINGS[Position.h1] = 0;
        PAWN_WHITE_WEIGHTINGS[Position.a2] = 0; PAWN_WHITE_WEIGHTINGS[Position.b2] = 0; PAWN_WHITE_WEIGHTINGS[Position.c2] = 0; PAWN_WHITE_WEIGHTINGS[Position.d2] = 0; PAWN_WHITE_WEIGHTINGS[Position.e2] = 0; PAWN_WHITE_WEIGHTINGS[Position.f2] = 0; PAWN_WHITE_WEIGHTINGS[Position.g2] = 0; PAWN_WHITE_WEIGHTINGS[Position.h2] = 0;
        PAWN_WHITE_WEIGHTINGS[Position.a3] = 0; PAWN_WHITE_WEIGHTINGS[Position.b3] = 0; PAWN_WHITE_WEIGHTINGS[Position.c3] = 0; PAWN_WHITE_WEIGHTINGS[Position.d3] = 5; PAWN_WHITE_WEIGHTINGS[Position.e3] = 5; PAWN_WHITE_WEIGHTINGS[Position.f3] = 0; PAWN_WHITE_WEIGHTINGS[Position.g3] = 0; PAWN_WHITE_WEIGHTINGS[Position.h3] = 0;
        PAWN_WHITE_WEIGHTINGS[Position.a4] = 0; PAWN_WHITE_WEIGHTINGS[Position.b4] = 0; PAWN_WHITE_WEIGHTINGS[Position.c4] = 3; PAWN_WHITE_WEIGHTINGS[Position.d4] = 10; PAWN_WHITE_WEIGHTINGS[Position.e4] = 10; PAWN_WHITE_WEIGHTINGS[Position.f4] = 3; PAWN_WHITE_WEIGHTINGS[Position.g4] = 0; PAWN_WHITE_WEIGHTINGS[Position.h4] = 0;
        PAWN_WHITE_WEIGHTINGS[Position.a5] = 0; PAWN_WHITE_WEIGHTINGS[Position.b5] = 0; PAWN_WHITE_WEIGHTINGS[Position.c5] = 0; PAWN_WHITE_WEIGHTINGS[Position.d5] = 0; PAWN_WHITE_WEIGHTINGS[Position.e5] = 0; PAWN_WHITE_WEIGHTINGS[Position.f5] = 0; PAWN_WHITE_WEIGHTINGS[Position.g5] = 0; PAWN_WHITE_WEIGHTINGS[Position.h5] = 0;
		PAWN_WHITE_WEIGHTINGS[Position.a6] = 0; PAWN_WHITE_WEIGHTINGS[Position.b6] = 0; PAWN_WHITE_WEIGHTINGS[Position.c6] = 0; PAWN_WHITE_WEIGHTINGS[Position.d6] = 0; PAWN_WHITE_WEIGHTINGS[Position.e6] = 0; PAWN_WHITE_WEIGHTINGS[Position.f6] = 0; PAWN_WHITE_WEIGHTINGS[Position.g6] = 0; PAWN_WHITE_WEIGHTINGS[Position.h6] = 0;
		PAWN_WHITE_WEIGHTINGS[Position.a7] = 0; PAWN_WHITE_WEIGHTINGS[Position.b7] = 0; PAWN_WHITE_WEIGHTINGS[Position.c7] = 0; PAWN_WHITE_WEIGHTINGS[Position.d7] = 0; PAWN_WHITE_WEIGHTINGS[Position.e7] = 0; PAWN_WHITE_WEIGHTINGS[Position.f7] = 0; PAWN_WHITE_WEIGHTINGS[Position.g7] = 0; PAWN_WHITE_WEIGHTINGS[Position.h7] = 0;
		PAWN_WHITE_WEIGHTINGS[Position.a8] = 0; PAWN_WHITE_WEIGHTINGS[Position.b8] = 0; PAWN_WHITE_WEIGHTINGS[Position.c8] = 0; PAWN_WHITE_WEIGHTINGS[Position.d8] = 0; PAWN_WHITE_WEIGHTINGS[Position.e8] = 0; PAWN_WHITE_WEIGHTINGS[Position.f8] = 0; PAWN_WHITE_WEIGHTINGS[Position.g8] = 0; PAWN_WHITE_WEIGHTINGS[Position.h8] = 0;
    }
    
	static final byte[] PAWN_BLACK_WEIGHTINGS;
    static {
    	PAWN_BLACK_WEIGHTINGS = new byte[128];
        PAWN_BLACK_WEIGHTINGS[Position.a1] = 0; PAWN_BLACK_WEIGHTINGS[Position.b1] = 0; PAWN_BLACK_WEIGHTINGS[Position.c1] = 0; PAWN_BLACK_WEIGHTINGS[Position.d1] = 0; PAWN_BLACK_WEIGHTINGS[Position.e1] = 0; PAWN_BLACK_WEIGHTINGS[Position.f1] = 0; PAWN_BLACK_WEIGHTINGS[Position.g1] = 0; PAWN_BLACK_WEIGHTINGS[Position.h1] = 0;
        PAWN_BLACK_WEIGHTINGS[Position.a2] = 0; PAWN_BLACK_WEIGHTINGS[Position.b2] = 0; PAWN_BLACK_WEIGHTINGS[Position.c2] = 0; PAWN_BLACK_WEIGHTINGS[Position.d2] = 0; PAWN_BLACK_WEIGHTINGS[Position.e2] = 0; PAWN_BLACK_WEIGHTINGS[Position.f2] = 0; PAWN_BLACK_WEIGHTINGS[Position.g2] = 0; PAWN_BLACK_WEIGHTINGS[Position.h2] = 0;
        PAWN_BLACK_WEIGHTINGS[Position.a3] = 0; PAWN_BLACK_WEIGHTINGS[Position.b3] = 0; PAWN_BLACK_WEIGHTINGS[Position.c3] = 0; PAWN_BLACK_WEIGHTINGS[Position.d3] = 0; PAWN_BLACK_WEIGHTINGS[Position.e3] = 0; PAWN_BLACK_WEIGHTINGS[Position.f3] = 0; PAWN_BLACK_WEIGHTINGS[Position.g3] = 0; PAWN_BLACK_WEIGHTINGS[Position.h3] = 0;
        PAWN_BLACK_WEIGHTINGS[Position.a4] = 0; PAWN_BLACK_WEIGHTINGS[Position.b4] = 0; PAWN_BLACK_WEIGHTINGS[Position.c4] = 0; PAWN_BLACK_WEIGHTINGS[Position.d4] = 0; PAWN_BLACK_WEIGHTINGS[Position.e4] = 0; PAWN_BLACK_WEIGHTINGS[Position.f4] = 0; PAWN_BLACK_WEIGHTINGS[Position.g4] = 0; PAWN_BLACK_WEIGHTINGS[Position.h4] = 0;
        PAWN_BLACK_WEIGHTINGS[Position.a5] = 0; PAWN_BLACK_WEIGHTINGS[Position.b5] = 0; PAWN_BLACK_WEIGHTINGS[Position.c5] = 3; PAWN_BLACK_WEIGHTINGS[Position.d5] = 10; PAWN_BLACK_WEIGHTINGS[Position.e5] = 10; PAWN_BLACK_WEIGHTINGS[Position.f5] = 3; PAWN_BLACK_WEIGHTINGS[Position.g5] = 0; PAWN_BLACK_WEIGHTINGS[Position.h5] = 0;
		PAWN_BLACK_WEIGHTINGS[Position.a6] = 0; PAWN_BLACK_WEIGHTINGS[Position.b6] = 0; PAWN_BLACK_WEIGHTINGS[Position.c6] = 0; PAWN_BLACK_WEIGHTINGS[Position.d6] = 5; PAWN_BLACK_WEIGHTINGS[Position.e6] = 5; PAWN_BLACK_WEIGHTINGS[Position.f6] = 0; PAWN_BLACK_WEIGHTINGS[Position.g6] = 0; PAWN_BLACK_WEIGHTINGS[Position.h6] = 0;
		PAWN_BLACK_WEIGHTINGS[Position.a7] = 0; PAWN_BLACK_WEIGHTINGS[Position.b7] = 0; PAWN_BLACK_WEIGHTINGS[Position.c7] = 0; PAWN_BLACK_WEIGHTINGS[Position.d7] = 0; PAWN_BLACK_WEIGHTINGS[Position.e7] = 0; PAWN_BLACK_WEIGHTINGS[Position.f7] = 0; PAWN_BLACK_WEIGHTINGS[Position.g7] = 0; PAWN_BLACK_WEIGHTINGS[Position.h7] = 0;
		PAWN_BLACK_WEIGHTINGS[Position.a8] = 0; PAWN_BLACK_WEIGHTINGS[Position.b8] = 0; PAWN_BLACK_WEIGHTINGS[Position.c8] = 0; PAWN_BLACK_WEIGHTINGS[Position.d8] = 0; PAWN_BLACK_WEIGHTINGS[Position.e8] = 0; PAWN_BLACK_WEIGHTINGS[Position.f8] = 0; PAWN_BLACK_WEIGHTINGS[Position.g8] = 0; PAWN_BLACK_WEIGHTINGS[Position.h8] = 0;
		for (int i=0;i<128;i++) {
			PAWN_BLACK_WEIGHTINGS[i] = (byte)-PAWN_BLACK_WEIGHTINGS[i];
		}
    }
    
	static final byte[] PAWN_WHITE_ENDGAME_WEIGHTINGS;
    static {
    	PAWN_WHITE_ENDGAME_WEIGHTINGS = new byte[128];
        PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.a1] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.b1] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.c1] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.d1] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.e1] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.f1] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.g1] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.h1] = 0;
        PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.a2] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.b2] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.c2] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.d2] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.e2] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.f2] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.g2] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.h2] = 0;
        PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.a3] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.b3] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.c3] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.d3] = 5; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.e3] = 5; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.f3] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.g3] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.h3] = 0;
        PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.a4] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.b4] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.c4] = 3; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.d4] = 8; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.e4] = 8;PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.f4] = 3; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.g4] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.h4] = 0;
        PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.a5] = 2; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.b5] = 3; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.c5] = 8; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.d5] = 12; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.e5] = 12; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.f5] = 8; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.g5] = 3; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.h5] = 2;
		PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.a6] = 4; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.b6] = 8; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.c6] = 12; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.d6] = 16; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.e6] = 16; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.f6] = 12; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.g6] = 8; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.h6] = 4;
		PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.a7] = 5; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.b7] = 10; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.c7] = 15; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.d7] = 20; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.e7] = 20; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.f7] = 15; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.g7] = 10; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.h7] = 5;
		PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.a8] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.b8] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.c8] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.d8] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.e8] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.f8] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.g8] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[Position.h8] = 0;
    }
    
	static final byte[] PAWN_BLACK_ENDGAME_WEIGHTINGS;
    static {
    	PAWN_BLACK_ENDGAME_WEIGHTINGS = new byte[128];
        PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.a1] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.b1] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.c1] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.d1] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.e1] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.f1] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.g1] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.h1] = 0;
        PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.a2] = 5; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.b2] = 10; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.c2] = 15; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.d2] = 20;PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.e2] = 20;PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.f2] = 15; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.g2] = 10; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.h2] = 5;
        PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.a3] = 4; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.b3] = 8; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.c3] = 12; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.d3] = 16;PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.e3] = 16;PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.f3] = 12; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.g3] = 8; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.h3] = 4;
        PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.a4] = 2; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.b4] = 3; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.c4] = 8; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.d4] = 12;PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.e4] = 12;PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.f4] = 8;PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.g4] = 3; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.h4] = 2;
        PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.a5] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.b5] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.c5] = 3; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.d5] = 8;PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.e5] = 8;PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.f5] = 3;PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.g5] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.h5] = 0;
		PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.a6] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.b6] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.c6] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.d6] = 5;PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.e6] = 5;PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.f6] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.g6] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.h6] = 0;
		PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.a7] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.b7] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.c7] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.d7] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.e7] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.f7] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.g7] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.h7] = 0;
		PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.a8] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.b8] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.c8] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.d8] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.e8] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.f8] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.g8] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[Position.h8] = 0;
		for (int i=0;i<128;i++) {
			PAWN_BLACK_ENDGAME_WEIGHTINGS[i] = (byte)-PAWN_BLACK_ENDGAME_WEIGHTINGS[i];
		}
    }  
    
	static final byte[] ROOK_WHITE_WEIGHTINGS;
    static {
    	ROOK_WHITE_WEIGHTINGS = new byte[128];
        ROOK_WHITE_WEIGHTINGS[Position.a1] = 0; ROOK_WHITE_WEIGHTINGS[Position.b1] = 0; ROOK_WHITE_WEIGHTINGS[Position.c1] = 0; ROOK_WHITE_WEIGHTINGS[Position.d1] = 5; ROOK_WHITE_WEIGHTINGS[Position.e1] = 5; ROOK_WHITE_WEIGHTINGS[Position.f1] = 0; ROOK_WHITE_WEIGHTINGS[Position.g1] = 0; ROOK_WHITE_WEIGHTINGS[Position.h1] = 0;
        ROOK_WHITE_WEIGHTINGS[Position.a2] = -10; ROOK_WHITE_WEIGHTINGS[Position.b2] = 0; ROOK_WHITE_WEIGHTINGS[Position.c2] = 0; ROOK_WHITE_WEIGHTINGS[Position.d2] = 5; ROOK_WHITE_WEIGHTINGS[Position.e2] = 5; ROOK_WHITE_WEIGHTINGS[Position.f2] = 0; ROOK_WHITE_WEIGHTINGS[Position.g2] = 0; ROOK_WHITE_WEIGHTINGS[Position.h2] = -10;
        ROOK_WHITE_WEIGHTINGS[Position.a3] = 0; ROOK_WHITE_WEIGHTINGS[Position.b3] = 0; ROOK_WHITE_WEIGHTINGS[Position.c3] = 0; ROOK_WHITE_WEIGHTINGS[Position.d3] = 5; ROOK_WHITE_WEIGHTINGS[Position.e3] = 5; ROOK_WHITE_WEIGHTINGS[Position.f3] = 0; ROOK_WHITE_WEIGHTINGS[Position.g3] = 0; ROOK_WHITE_WEIGHTINGS[Position.h3] = 0;
        ROOK_WHITE_WEIGHTINGS[Position.a4] = 0; ROOK_WHITE_WEIGHTINGS[Position.b4] = 0; ROOK_WHITE_WEIGHTINGS[Position.c4] = 0; ROOK_WHITE_WEIGHTINGS[Position.d4] = 5; ROOK_WHITE_WEIGHTINGS[Position.e4] = 5; ROOK_WHITE_WEIGHTINGS[Position.f4] = 0; ROOK_WHITE_WEIGHTINGS[Position.g4] = 0; ROOK_WHITE_WEIGHTINGS[Position.h4] = 0;
        ROOK_WHITE_WEIGHTINGS[Position.a5] = 0; ROOK_WHITE_WEIGHTINGS[Position.b5] = 0; ROOK_WHITE_WEIGHTINGS[Position.c5] = 0; ROOK_WHITE_WEIGHTINGS[Position.d5] = 5; ROOK_WHITE_WEIGHTINGS[Position.e5] = 5; ROOK_WHITE_WEIGHTINGS[Position.f5] = 0; ROOK_WHITE_WEIGHTINGS[Position.g5] = 0; ROOK_WHITE_WEIGHTINGS[Position.h5] = 0;
		ROOK_WHITE_WEIGHTINGS[Position.a6] = 0; ROOK_WHITE_WEIGHTINGS[Position.b6] = 0; ROOK_WHITE_WEIGHTINGS[Position.c6] = 0; ROOK_WHITE_WEIGHTINGS[Position.d6] = 5; ROOK_WHITE_WEIGHTINGS[Position.e6] = 5; ROOK_WHITE_WEIGHTINGS[Position.f6] = 0; ROOK_WHITE_WEIGHTINGS[Position.g6] = 0; ROOK_WHITE_WEIGHTINGS[Position.h6] = 0;
		ROOK_WHITE_WEIGHTINGS[Position.a7] = 20; ROOK_WHITE_WEIGHTINGS[Position.b7] = 20; ROOK_WHITE_WEIGHTINGS[Position.c7] = 20; ROOK_WHITE_WEIGHTINGS[Position.d7] = 20; ROOK_WHITE_WEIGHTINGS[Position.e7] = 20; ROOK_WHITE_WEIGHTINGS[Position.f7] = 20; ROOK_WHITE_WEIGHTINGS[Position.g7] = 20; ROOK_WHITE_WEIGHTINGS[Position.h7] = 20;
		ROOK_WHITE_WEIGHTINGS[Position.a8] = 0; ROOK_WHITE_WEIGHTINGS[Position.b8] = 0; ROOK_WHITE_WEIGHTINGS[Position.c8] = 0; ROOK_WHITE_WEIGHTINGS[Position.d8] = 5; ROOK_WHITE_WEIGHTINGS[Position.e8] = 5; ROOK_WHITE_WEIGHTINGS[Position.f8] = 0; ROOK_WHITE_WEIGHTINGS[Position.g8] = 0; ROOK_WHITE_WEIGHTINGS[Position.h8] = 0;
    }
    
	static final byte[] ROOK_BLACK_WEIGHTINGS;
    static {
    	ROOK_BLACK_WEIGHTINGS = new byte[128];
        ROOK_BLACK_WEIGHTINGS[Position.a1] = 0; ROOK_BLACK_WEIGHTINGS[Position.b1] = 0; ROOK_BLACK_WEIGHTINGS[Position.c1] = 0; ROOK_BLACK_WEIGHTINGS[Position.d1] = 5; ROOK_BLACK_WEIGHTINGS[Position.e1] = 5; ROOK_BLACK_WEIGHTINGS[Position.f1] = 0; ROOK_BLACK_WEIGHTINGS[Position.g1] = 0; ROOK_BLACK_WEIGHTINGS[Position.h1] = 0;
        ROOK_BLACK_WEIGHTINGS[Position.a2] = 20; ROOK_BLACK_WEIGHTINGS[Position.b2] = 20; ROOK_BLACK_WEIGHTINGS[Position.c2] = 20; ROOK_BLACK_WEIGHTINGS[Position.d2] = 20; ROOK_BLACK_WEIGHTINGS[Position.e2] = 20; ROOK_BLACK_WEIGHTINGS[Position.f2] = 20; ROOK_BLACK_WEIGHTINGS[Position.g2] = 20; ROOK_BLACK_WEIGHTINGS[Position.h2] = 20;
        ROOK_BLACK_WEIGHTINGS[Position.a3] = 0; ROOK_BLACK_WEIGHTINGS[Position.b3] = 0; ROOK_BLACK_WEIGHTINGS[Position.c3] = 0; ROOK_BLACK_WEIGHTINGS[Position.d3] = 5; ROOK_BLACK_WEIGHTINGS[Position.e3] = 5; ROOK_BLACK_WEIGHTINGS[Position.f3] = 0; ROOK_BLACK_WEIGHTINGS[Position.g3] = 0; ROOK_BLACK_WEIGHTINGS[Position.h3] = 0;
        ROOK_BLACK_WEIGHTINGS[Position.a4] = 0; ROOK_BLACK_WEIGHTINGS[Position.b4] = 0; ROOK_BLACK_WEIGHTINGS[Position.c4] = 0; ROOK_BLACK_WEIGHTINGS[Position.d4] = 5; ROOK_BLACK_WEIGHTINGS[Position.e4] = 5; ROOK_BLACK_WEIGHTINGS[Position.f4] = 0; ROOK_BLACK_WEIGHTINGS[Position.g4] = 0; ROOK_BLACK_WEIGHTINGS[Position.h4] = 0;
        ROOK_BLACK_WEIGHTINGS[Position.a5] = 0; ROOK_BLACK_WEIGHTINGS[Position.b5] = 0; ROOK_BLACK_WEIGHTINGS[Position.c5] = 0; ROOK_BLACK_WEIGHTINGS[Position.d5] = 5; ROOK_BLACK_WEIGHTINGS[Position.e5] = 5; ROOK_BLACK_WEIGHTINGS[Position.f5] = 0; ROOK_BLACK_WEIGHTINGS[Position.g5] = 0; ROOK_BLACK_WEIGHTINGS[Position.h5] = 0;
		ROOK_BLACK_WEIGHTINGS[Position.a6] = 0; ROOK_BLACK_WEIGHTINGS[Position.b6] = 0; ROOK_BLACK_WEIGHTINGS[Position.c6] = 0; ROOK_BLACK_WEIGHTINGS[Position.d6] = 5; ROOK_BLACK_WEIGHTINGS[Position.e6] = 5; ROOK_BLACK_WEIGHTINGS[Position.f6] = 0; ROOK_BLACK_WEIGHTINGS[Position.g6] = 0; ROOK_BLACK_WEIGHTINGS[Position.h6] = 0;
		ROOK_BLACK_WEIGHTINGS[Position.a7] = -10; ROOK_BLACK_WEIGHTINGS[Position.b7] = 0; ROOK_BLACK_WEIGHTINGS[Position.c7] = 0; ROOK_BLACK_WEIGHTINGS[Position.d7] = 5; ROOK_BLACK_WEIGHTINGS[Position.e7] = 5; ROOK_BLACK_WEIGHTINGS[Position.f7] = 0; ROOK_BLACK_WEIGHTINGS[Position.g7] = 0; ROOK_BLACK_WEIGHTINGS[Position.h7] = -10;
		ROOK_BLACK_WEIGHTINGS[Position.a8] = 0; ROOK_BLACK_WEIGHTINGS[Position.b8] = 0; ROOK_BLACK_WEIGHTINGS[Position.c8] = 0; ROOK_BLACK_WEIGHTINGS[Position.d8] = 5; ROOK_BLACK_WEIGHTINGS[Position.e8] = 5; ROOK_BLACK_WEIGHTINGS[Position.f8] = 0; ROOK_BLACK_WEIGHTINGS[Position.g8] = 0; ROOK_BLACK_WEIGHTINGS[Position.h8] = 0;
		for (int i=0;i<128;i++) {
			ROOK_BLACK_WEIGHTINGS[i] = (byte)-ROOK_BLACK_WEIGHTINGS[i];
		}
    }
	
	static final byte[] KNIGHT_WHITE_WEIGHTINGS;
    static {
    	KNIGHT_WHITE_WEIGHTINGS = new byte[128];
        KNIGHT_WHITE_WEIGHTINGS[Position.a1] = -20;KNIGHT_WHITE_WEIGHTINGS[Position.b1] = -10;KNIGHT_WHITE_WEIGHTINGS[Position.c1] = -10;KNIGHT_WHITE_WEIGHTINGS[Position.d1] = -10;KNIGHT_WHITE_WEIGHTINGS[Position.e1] = -10;KNIGHT_WHITE_WEIGHTINGS[Position.f1] = -10;KNIGHT_WHITE_WEIGHTINGS[Position.g1] = -10;KNIGHT_WHITE_WEIGHTINGS[Position.h1] = -20;
		KNIGHT_WHITE_WEIGHTINGS[Position.a2] = -10;KNIGHT_WHITE_WEIGHTINGS[Position.b2] = 0;KNIGHT_WHITE_WEIGHTINGS[Position.c2] = 0;KNIGHT_WHITE_WEIGHTINGS[Position.d2] = 0;KNIGHT_WHITE_WEIGHTINGS[Position.e2] = 0;KNIGHT_WHITE_WEIGHTINGS[Position.f2] = 0;KNIGHT_WHITE_WEIGHTINGS[Position.g2] = 0;KNIGHT_WHITE_WEIGHTINGS[Position.h2] = -10;
		KNIGHT_WHITE_WEIGHTINGS[Position.a3] = -10;KNIGHT_WHITE_WEIGHTINGS[Position.b3] = 0;KNIGHT_WHITE_WEIGHTINGS[Position.c3] = 10;KNIGHT_WHITE_WEIGHTINGS[Position.d3] = 10;KNIGHT_WHITE_WEIGHTINGS[Position.e3] = 10;KNIGHT_WHITE_WEIGHTINGS[Position.f3] = 10;KNIGHT_WHITE_WEIGHTINGS[Position.g3] = 0;KNIGHT_WHITE_WEIGHTINGS[Position.h3] = -10;
		KNIGHT_WHITE_WEIGHTINGS[Position.a4] = -10;KNIGHT_WHITE_WEIGHTINGS[Position.b4] = 0;KNIGHT_WHITE_WEIGHTINGS[Position.c4] = 10;KNIGHT_WHITE_WEIGHTINGS[Position.d4] = 20;KNIGHT_WHITE_WEIGHTINGS[Position.e4] = 20;KNIGHT_WHITE_WEIGHTINGS[Position.f4] = 10;KNIGHT_WHITE_WEIGHTINGS[Position.g4] = 0;KNIGHT_WHITE_WEIGHTINGS[Position.h4] = -10;
		KNIGHT_WHITE_WEIGHTINGS[Position.a5] = -10;KNIGHT_WHITE_WEIGHTINGS[Position.b5] = 0;KNIGHT_WHITE_WEIGHTINGS[Position.c5] = 10;KNIGHT_WHITE_WEIGHTINGS[Position.d5] = 20;KNIGHT_WHITE_WEIGHTINGS[Position.e5] = 20;KNIGHT_WHITE_WEIGHTINGS[Position.f5] = 10;KNIGHT_WHITE_WEIGHTINGS[Position.g5] = 0;KNIGHT_WHITE_WEIGHTINGS[Position.h5] = -10;
		KNIGHT_WHITE_WEIGHTINGS[Position.a6] = -10;KNIGHT_WHITE_WEIGHTINGS[Position.b6] = 0;KNIGHT_WHITE_WEIGHTINGS[Position.c6] = 10;KNIGHT_WHITE_WEIGHTINGS[Position.d6] = 10;KNIGHT_WHITE_WEIGHTINGS[Position.e6] = 10;KNIGHT_WHITE_WEIGHTINGS[Position.f6] = 10;KNIGHT_WHITE_WEIGHTINGS[Position.g6] = 0;KNIGHT_WHITE_WEIGHTINGS[Position.h6] = -10;
		KNIGHT_WHITE_WEIGHTINGS[Position.a7] = -10;KNIGHT_WHITE_WEIGHTINGS[Position.b7] = 0;KNIGHT_WHITE_WEIGHTINGS[Position.c7] = 0;KNIGHT_WHITE_WEIGHTINGS[Position.d7] = 0;KNIGHT_WHITE_WEIGHTINGS[Position.e7] = 0;KNIGHT_WHITE_WEIGHTINGS[Position.f7] = 0;KNIGHT_WHITE_WEIGHTINGS[Position.g7] = 0;KNIGHT_WHITE_WEIGHTINGS[Position.h7] = -10;
		KNIGHT_WHITE_WEIGHTINGS[Position.a8] = -20;KNIGHT_WHITE_WEIGHTINGS[Position.b8] = -10;KNIGHT_WHITE_WEIGHTINGS[Position.c8] = -10;KNIGHT_WHITE_WEIGHTINGS[Position.d8] = -10;KNIGHT_WHITE_WEIGHTINGS[Position.e8] = -10;KNIGHT_WHITE_WEIGHTINGS[Position.f8] = -10;KNIGHT_WHITE_WEIGHTINGS[Position.g8] = -10;KNIGHT_WHITE_WEIGHTINGS[Position.h8] = -20;
    }
    
	static final byte[] KNIGHT_BLACK_WEIGHTINGS;
    static {
    	KNIGHT_BLACK_WEIGHTINGS = new byte[128];
        KNIGHT_BLACK_WEIGHTINGS[Position.a1] = -20;KNIGHT_BLACK_WEIGHTINGS[Position.b1] = -10;KNIGHT_BLACK_WEIGHTINGS[Position.c1] = -10;KNIGHT_BLACK_WEIGHTINGS[Position.d1] = -10;KNIGHT_BLACK_WEIGHTINGS[Position.e1] = -10;KNIGHT_BLACK_WEIGHTINGS[Position.f1] = -10;KNIGHT_BLACK_WEIGHTINGS[Position.g1] = -10;KNIGHT_BLACK_WEIGHTINGS[Position.h1] = -20;
		KNIGHT_BLACK_WEIGHTINGS[Position.a2] = -10;KNIGHT_BLACK_WEIGHTINGS[Position.b2] = 0;KNIGHT_BLACK_WEIGHTINGS[Position.c2] = 0;KNIGHT_BLACK_WEIGHTINGS[Position.d2] = 0;KNIGHT_BLACK_WEIGHTINGS[Position.e2] = 0;KNIGHT_BLACK_WEIGHTINGS[Position.f2] = 0;KNIGHT_BLACK_WEIGHTINGS[Position.g2] = 0;KNIGHT_BLACK_WEIGHTINGS[Position.h2] = -10;
		KNIGHT_BLACK_WEIGHTINGS[Position.a3] = -10;KNIGHT_BLACK_WEIGHTINGS[Position.b3] = 0;KNIGHT_BLACK_WEIGHTINGS[Position.c3] = 10;KNIGHT_BLACK_WEIGHTINGS[Position.d3] = 10;KNIGHT_BLACK_WEIGHTINGS[Position.e3] = 10;KNIGHT_BLACK_WEIGHTINGS[Position.f3] = 10;KNIGHT_BLACK_WEIGHTINGS[Position.g3] = 0;KNIGHT_BLACK_WEIGHTINGS[Position.h3] = -10;
		KNIGHT_BLACK_WEIGHTINGS[Position.a4] = -10;KNIGHT_BLACK_WEIGHTINGS[Position.b4] = 0;KNIGHT_BLACK_WEIGHTINGS[Position.c4] = 10;KNIGHT_BLACK_WEIGHTINGS[Position.d4] = 20;KNIGHT_BLACK_WEIGHTINGS[Position.e4] = 20;KNIGHT_BLACK_WEIGHTINGS[Position.f4] = 10;KNIGHT_BLACK_WEIGHTINGS[Position.g4] = 0;KNIGHT_BLACK_WEIGHTINGS[Position.h4] = -10;
		KNIGHT_BLACK_WEIGHTINGS[Position.a5] = -10;KNIGHT_BLACK_WEIGHTINGS[Position.b5] = 0;KNIGHT_BLACK_WEIGHTINGS[Position.c5] = 10;KNIGHT_BLACK_WEIGHTINGS[Position.d5] = 20;KNIGHT_BLACK_WEIGHTINGS[Position.e5] = 20;KNIGHT_BLACK_WEIGHTINGS[Position.f5] = 10;KNIGHT_BLACK_WEIGHTINGS[Position.g5] = 0;KNIGHT_BLACK_WEIGHTINGS[Position.h5] = -10;
		KNIGHT_BLACK_WEIGHTINGS[Position.a6] = -10;KNIGHT_BLACK_WEIGHTINGS[Position.b6] = 0;KNIGHT_BLACK_WEIGHTINGS[Position.c6] = 10;KNIGHT_BLACK_WEIGHTINGS[Position.d6] = 10;KNIGHT_BLACK_WEIGHTINGS[Position.e6] = 10;KNIGHT_BLACK_WEIGHTINGS[Position.f6] = 10;KNIGHT_BLACK_WEIGHTINGS[Position.g6] = 0;KNIGHT_BLACK_WEIGHTINGS[Position.h6] = -10;
		KNIGHT_BLACK_WEIGHTINGS[Position.a7] = -10;KNIGHT_BLACK_WEIGHTINGS[Position.b7] = 0;KNIGHT_BLACK_WEIGHTINGS[Position.c7] = 0;KNIGHT_BLACK_WEIGHTINGS[Position.d7] = 0;KNIGHT_BLACK_WEIGHTINGS[Position.e7] = 0;KNIGHT_BLACK_WEIGHTINGS[Position.f7] = 0;KNIGHT_BLACK_WEIGHTINGS[Position.g7] = 0;KNIGHT_BLACK_WEIGHTINGS[Position.h7] = -10;
		KNIGHT_BLACK_WEIGHTINGS[Position.a8] = -20;KNIGHT_BLACK_WEIGHTINGS[Position.b8] = -10;KNIGHT_BLACK_WEIGHTINGS[Position.c8] = -10;KNIGHT_BLACK_WEIGHTINGS[Position.d8] = -10;KNIGHT_BLACK_WEIGHTINGS[Position.e8] = -10;KNIGHT_BLACK_WEIGHTINGS[Position.f8] = -10;KNIGHT_BLACK_WEIGHTINGS[Position.g8] = -10;KNIGHT_BLACK_WEIGHTINGS[Position.h8] = -20;
		for (int i=0;i<128;i++) {
			KNIGHT_BLACK_WEIGHTINGS[i] = (byte)-KNIGHT_BLACK_WEIGHTINGS[i];
		}
    }
    
    static final byte[] KING_WHITE_ENDGAME_WEIGHTINGS;
    static {
    	KING_WHITE_ENDGAME_WEIGHTINGS = new byte[128];
        KING_WHITE_ENDGAME_WEIGHTINGS[Position.a1] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[Position.b1] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[Position.c1] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[Position.d1] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[Position.e1] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[Position.f1] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[Position.g1] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[Position.h1] = -30;
		KING_WHITE_ENDGAME_WEIGHTINGS[Position.a2] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[Position.b2] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[Position.c2] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[Position.d2] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[Position.e2] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[Position.f2] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[Position.g2] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[Position.h2] = -30;
		KING_WHITE_ENDGAME_WEIGHTINGS[Position.a3] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[Position.b3] = -10;KING_WHITE_ENDGAME_WEIGHTINGS[Position.c3] = 0;KING_WHITE_ENDGAME_WEIGHTINGS[Position.d3] = 10;KING_WHITE_ENDGAME_WEIGHTINGS[Position.e3] = 10;KING_WHITE_ENDGAME_WEIGHTINGS[Position.f3] = 0;KING_WHITE_ENDGAME_WEIGHTINGS[Position.g3] = -10;KING_WHITE_ENDGAME_WEIGHTINGS[Position.h3] = -30;
		KING_WHITE_ENDGAME_WEIGHTINGS[Position.a4] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[Position.b4] = -10;KING_WHITE_ENDGAME_WEIGHTINGS[Position.c4] = 10;KING_WHITE_ENDGAME_WEIGHTINGS[Position.d4] = 20;KING_WHITE_ENDGAME_WEIGHTINGS[Position.e4] = 20;KING_WHITE_ENDGAME_WEIGHTINGS[Position.f4] = 10;KING_WHITE_ENDGAME_WEIGHTINGS[Position.g4] = -10;KING_WHITE_ENDGAME_WEIGHTINGS[Position.h4] = -20;
		KING_WHITE_ENDGAME_WEIGHTINGS[Position.a5] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[Position.b5] = -10;KING_WHITE_ENDGAME_WEIGHTINGS[Position.c5] = 10;KING_WHITE_ENDGAME_WEIGHTINGS[Position.d5] = 20;KING_WHITE_ENDGAME_WEIGHTINGS[Position.e5] = 20;KING_WHITE_ENDGAME_WEIGHTINGS[Position.f5] = 10;KING_WHITE_ENDGAME_WEIGHTINGS[Position.g5] = -10;KING_WHITE_ENDGAME_WEIGHTINGS[Position.h5] = -20;
		KING_WHITE_ENDGAME_WEIGHTINGS[Position.a6] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[Position.b6] = -10;KING_WHITE_ENDGAME_WEIGHTINGS[Position.c6] = 0;KING_WHITE_ENDGAME_WEIGHTINGS[Position.d6] = 10;KING_WHITE_ENDGAME_WEIGHTINGS[Position.e6] = 10;KING_WHITE_ENDGAME_WEIGHTINGS[Position.f6] = 0;KING_WHITE_ENDGAME_WEIGHTINGS[Position.g6] = -10;KING_WHITE_ENDGAME_WEIGHTINGS[Position.h6] = -30;
		KING_WHITE_ENDGAME_WEIGHTINGS[Position.a7] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[Position.b7] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[Position.c7] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[Position.d7] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[Position.e7] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[Position.f7] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[Position.g7] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[Position.h7] = -30;
		KING_WHITE_ENDGAME_WEIGHTINGS[Position.a8] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[Position.b8] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[Position.c8] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[Position.d8] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[Position.e8] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[Position.f8] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[Position.g8] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[Position.h8] = -30;
    }
    
    static final byte[] KING_WHITE_MIDGAME_WEIGHTINGS;
    static {
    	KING_WHITE_MIDGAME_WEIGHTINGS = new byte[128];
        KING_WHITE_MIDGAME_WEIGHTINGS[Position.a1] = 5;KING_WHITE_MIDGAME_WEIGHTINGS[Position.b1] = 25;KING_WHITE_MIDGAME_WEIGHTINGS[Position.c1] = 50;KING_WHITE_MIDGAME_WEIGHTINGS[Position.d1] = 0;KING_WHITE_MIDGAME_WEIGHTINGS[Position.e1] = 0;KING_WHITE_MIDGAME_WEIGHTINGS[Position.f1] = 5;KING_WHITE_MIDGAME_WEIGHTINGS[Position.g1] = 50;KING_WHITE_MIDGAME_WEIGHTINGS[Position.h1] = 5;
		KING_WHITE_MIDGAME_WEIGHTINGS[Position.a2] = 0;KING_WHITE_MIDGAME_WEIGHTINGS[Position.b2] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[Position.c2] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[Position.d2] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[Position.e2] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[Position.f2] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[Position.g2] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[Position.h2] = -10;
		KING_WHITE_MIDGAME_WEIGHTINGS[Position.a3] = -20;KING_WHITE_MIDGAME_WEIGHTINGS[Position.b3] = -20;KING_WHITE_MIDGAME_WEIGHTINGS[Position.c3] = -30;KING_WHITE_MIDGAME_WEIGHTINGS[Position.d3] = -30;KING_WHITE_MIDGAME_WEIGHTINGS[Position.e3] = -30;KING_WHITE_MIDGAME_WEIGHTINGS[Position.f3] = -30;KING_WHITE_MIDGAME_WEIGHTINGS[Position.g3] = -20;KING_WHITE_MIDGAME_WEIGHTINGS[Position.h3] = -20;
		KING_WHITE_MIDGAME_WEIGHTINGS[Position.a4] = -30;KING_WHITE_MIDGAME_WEIGHTINGS[Position.b4] = -40;KING_WHITE_MIDGAME_WEIGHTINGS[Position.c4] = -50;KING_WHITE_MIDGAME_WEIGHTINGS[Position.d4] = -50;KING_WHITE_MIDGAME_WEIGHTINGS[Position.e4] = -50;KING_WHITE_MIDGAME_WEIGHTINGS[Position.f4] = -40;KING_WHITE_MIDGAME_WEIGHTINGS[Position.g4] = -40;KING_WHITE_MIDGAME_WEIGHTINGS[Position.h4] = -30;
		KING_WHITE_MIDGAME_WEIGHTINGS[Position.a5] = -30;KING_WHITE_MIDGAME_WEIGHTINGS[Position.b5] = -40;KING_WHITE_MIDGAME_WEIGHTINGS[Position.c5] = -50;KING_WHITE_MIDGAME_WEIGHTINGS[Position.d5] = -50;KING_WHITE_MIDGAME_WEIGHTINGS[Position.e5] = -50;KING_WHITE_MIDGAME_WEIGHTINGS[Position.f5] = -40;KING_WHITE_MIDGAME_WEIGHTINGS[Position.g5] = -40;KING_WHITE_MIDGAME_WEIGHTINGS[Position.h5] = -30;
		KING_WHITE_MIDGAME_WEIGHTINGS[Position.a6] = -20;KING_WHITE_MIDGAME_WEIGHTINGS[Position.b6] = -20;KING_WHITE_MIDGAME_WEIGHTINGS[Position.c6] = -30;KING_WHITE_MIDGAME_WEIGHTINGS[Position.d6] = -30;KING_WHITE_MIDGAME_WEIGHTINGS[Position.e6] = -30;KING_WHITE_MIDGAME_WEIGHTINGS[Position.f6] = -30;KING_WHITE_MIDGAME_WEIGHTINGS[Position.g6] = -20;KING_WHITE_MIDGAME_WEIGHTINGS[Position.h6] = -20;
		KING_WHITE_MIDGAME_WEIGHTINGS[Position.a7] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[Position.b7] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[Position.c7] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[Position.d7] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[Position.e7] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[Position.f7] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[Position.g7] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[Position.h7] = -10;
		KING_WHITE_MIDGAME_WEIGHTINGS[Position.a8] = 5;KING_WHITE_MIDGAME_WEIGHTINGS[Position.b8] = 25;KING_WHITE_MIDGAME_WEIGHTINGS[Position.c8] = 50;KING_WHITE_MIDGAME_WEIGHTINGS[Position.d8] = 0;KING_WHITE_MIDGAME_WEIGHTINGS[Position.e8] = 0;KING_WHITE_MIDGAME_WEIGHTINGS[Position.f8] = 5;KING_WHITE_MIDGAME_WEIGHTINGS[Position.g8] = 50;KING_WHITE_MIDGAME_WEIGHTINGS[Position.h8] = 5;
    }
    
    static final byte[] KING_BLACK_ENDGAME_WEIGHTINGS;
    static {
    	KING_BLACK_ENDGAME_WEIGHTINGS = new byte[128];
        KING_BLACK_ENDGAME_WEIGHTINGS[Position.a1] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.b1] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.c1] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.d1] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.e1] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.f1] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.g1] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.h1] = -30;
		KING_BLACK_ENDGAME_WEIGHTINGS[Position.a2] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.b2] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[Position.c2] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[Position.d2] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[Position.e2] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[Position.f2] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[Position.g2] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[Position.h2] = -30;
		KING_BLACK_ENDGAME_WEIGHTINGS[Position.a3] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.b3] = -10;KING_BLACK_ENDGAME_WEIGHTINGS[Position.c3] = 0;KING_BLACK_ENDGAME_WEIGHTINGS[Position.d3] = 10;KING_BLACK_ENDGAME_WEIGHTINGS[Position.e3] = 10;KING_BLACK_ENDGAME_WEIGHTINGS[Position.f3] = 0;KING_BLACK_ENDGAME_WEIGHTINGS[Position.g3] = -10;KING_BLACK_ENDGAME_WEIGHTINGS[Position.h3] = -30;
		KING_BLACK_ENDGAME_WEIGHTINGS[Position.a4] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[Position.b4] = -10;KING_BLACK_ENDGAME_WEIGHTINGS[Position.c4] = 10;KING_BLACK_ENDGAME_WEIGHTINGS[Position.d4] = 20;KING_BLACK_ENDGAME_WEIGHTINGS[Position.e4] = 20;KING_BLACK_ENDGAME_WEIGHTINGS[Position.f4] = 10;KING_BLACK_ENDGAME_WEIGHTINGS[Position.g4] = -10;KING_BLACK_ENDGAME_WEIGHTINGS[Position.h4] = -20;
		KING_BLACK_ENDGAME_WEIGHTINGS[Position.a5] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[Position.b5] = -10;KING_BLACK_ENDGAME_WEIGHTINGS[Position.c5] = 10;KING_BLACK_ENDGAME_WEIGHTINGS[Position.d5] = 20;KING_BLACK_ENDGAME_WEIGHTINGS[Position.e5] = 20;KING_BLACK_ENDGAME_WEIGHTINGS[Position.f5] = 10;KING_BLACK_ENDGAME_WEIGHTINGS[Position.g5] = -10;KING_BLACK_ENDGAME_WEIGHTINGS[Position.h5] = -20;
		KING_BLACK_ENDGAME_WEIGHTINGS[Position.a6] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.b6] = -10;KING_BLACK_ENDGAME_WEIGHTINGS[Position.c6] = 0;KING_BLACK_ENDGAME_WEIGHTINGS[Position.d6] = 10;KING_BLACK_ENDGAME_WEIGHTINGS[Position.e6] = 10;KING_BLACK_ENDGAME_WEIGHTINGS[Position.f6] = 0;KING_BLACK_ENDGAME_WEIGHTINGS[Position.g6] = -10;KING_BLACK_ENDGAME_WEIGHTINGS[Position.h6] = -30;
		KING_BLACK_ENDGAME_WEIGHTINGS[Position.a7] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.b7] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[Position.c7] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[Position.d7] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[Position.e7] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[Position.f7] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[Position.g7] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[Position.h7] = -30;
		KING_BLACK_ENDGAME_WEIGHTINGS[Position.a8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.b8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.c8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.d8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.e8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.f8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.g8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.h8] = -30;
		for (int i=0;i<128;i++) {
			KING_BLACK_ENDGAME_WEIGHTINGS[i] = (byte)-KING_BLACK_ENDGAME_WEIGHTINGS[i];
		}
    }
    
    static final byte[] KING_BLACK_MIDGAME_WEIGHTINGS;
    static {
    	KING_BLACK_MIDGAME_WEIGHTINGS = new byte[128];
        KING_BLACK_MIDGAME_WEIGHTINGS[Position.a1] = 5;KING_BLACK_MIDGAME_WEIGHTINGS[Position.b1] = 25;KING_BLACK_MIDGAME_WEIGHTINGS[Position.c1] = 50;KING_BLACK_MIDGAME_WEIGHTINGS[Position.d1] = 0;KING_BLACK_MIDGAME_WEIGHTINGS[Position.e1] = 0;KING_BLACK_MIDGAME_WEIGHTINGS[Position.f1] = 5;KING_BLACK_MIDGAME_WEIGHTINGS[Position.g1] = 50;KING_BLACK_MIDGAME_WEIGHTINGS[Position.h1] = 5;
		KING_BLACK_MIDGAME_WEIGHTINGS[Position.a2] = 0;KING_BLACK_MIDGAME_WEIGHTINGS[Position.b2] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[Position.c2] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[Position.d2] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[Position.e2] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[Position.f2] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[Position.g2] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[Position.h2] = -10;
		KING_BLACK_MIDGAME_WEIGHTINGS[Position.a3] = -20;KING_BLACK_MIDGAME_WEIGHTINGS[Position.b3] = -20;KING_BLACK_MIDGAME_WEIGHTINGS[Position.c3] = -30;KING_BLACK_MIDGAME_WEIGHTINGS[Position.d3] = -30;KING_BLACK_MIDGAME_WEIGHTINGS[Position.e3] = -30;KING_BLACK_MIDGAME_WEIGHTINGS[Position.f3] = -30;KING_BLACK_MIDGAME_WEIGHTINGS[Position.g3] = -20;KING_BLACK_MIDGAME_WEIGHTINGS[Position.h3] = -20;
		KING_BLACK_MIDGAME_WEIGHTINGS[Position.a4] = -30;KING_BLACK_MIDGAME_WEIGHTINGS[Position.b4] = -40;KING_BLACK_MIDGAME_WEIGHTINGS[Position.c4] = -50;KING_BLACK_MIDGAME_WEIGHTINGS[Position.d4] = -50;KING_BLACK_MIDGAME_WEIGHTINGS[Position.e4] = -50;KING_BLACK_MIDGAME_WEIGHTINGS[Position.f4] = -40;KING_BLACK_MIDGAME_WEIGHTINGS[Position.g4] = -40;KING_BLACK_MIDGAME_WEIGHTINGS[Position.h4] = -30;
		KING_BLACK_MIDGAME_WEIGHTINGS[Position.a5] = -30;KING_BLACK_MIDGAME_WEIGHTINGS[Position.b5] = -40;KING_BLACK_MIDGAME_WEIGHTINGS[Position.c5] = -50;KING_BLACK_MIDGAME_WEIGHTINGS[Position.d5] = -50;KING_BLACK_MIDGAME_WEIGHTINGS[Position.e5] = -50;KING_BLACK_MIDGAME_WEIGHTINGS[Position.f5] = -40;KING_BLACK_MIDGAME_WEIGHTINGS[Position.g5] = -40;KING_BLACK_MIDGAME_WEIGHTINGS[Position.h5] = -30;
		KING_BLACK_MIDGAME_WEIGHTINGS[Position.a6] = -20;KING_BLACK_MIDGAME_WEIGHTINGS[Position.b6] = -20;KING_BLACK_MIDGAME_WEIGHTINGS[Position.c6] = -30;KING_BLACK_MIDGAME_WEIGHTINGS[Position.d6] = -30;KING_BLACK_MIDGAME_WEIGHTINGS[Position.e6] = -30;KING_BLACK_MIDGAME_WEIGHTINGS[Position.f6] = -30;KING_BLACK_MIDGAME_WEIGHTINGS[Position.g6] = -20;KING_BLACK_MIDGAME_WEIGHTINGS[Position.h6] = -20;
		KING_BLACK_MIDGAME_WEIGHTINGS[Position.a7] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[Position.b7] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[Position.c7] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[Position.d7] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[Position.e7] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[Position.f7] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[Position.g7] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[Position.h7] = -10;
		KING_BLACK_MIDGAME_WEIGHTINGS[Position.a8] = 5;KING_BLACK_MIDGAME_WEIGHTINGS[Position.b8] = 25;KING_BLACK_MIDGAME_WEIGHTINGS[Position.c8] = 50;KING_BLACK_MIDGAME_WEIGHTINGS[Position.d8] = 0;KING_BLACK_MIDGAME_WEIGHTINGS[Position.e8] = 0;KING_BLACK_MIDGAME_WEIGHTINGS[Position.f8] = 5;KING_BLACK_MIDGAME_WEIGHTINGS[Position.g8] = 50;KING_BLACK_MIDGAME_WEIGHTINGS[Position.h8] = 5;
		KING_BLACK_ENDGAME_WEIGHTINGS[Position.a8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.b8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.c8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.d8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.e8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.f8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.g8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[Position.h8] = -30;
		for (int i=0;i<128;i++) {
			KING_BLACK_MIDGAME_WEIGHTINGS[i] = (byte)-KING_BLACK_MIDGAME_WEIGHTINGS[i];
		}
    }
    
    static final byte[] ZERO_WEIGHTING = new byte[128];
    
    static final byte [][] PIECE_SQUARE_TABLES;
    static {
    	PIECE_SQUARE_TABLES = new byte[15][128];
    	
    	PIECE_SQUARE_TABLES[Piece.WHITE_PAWN] = PAWN_WHITE_WEIGHTINGS;
    	PIECE_SQUARE_TABLES[Piece.WHITE_KING] = KING_WHITE_MIDGAME_WEIGHTINGS;
    	PIECE_SQUARE_TABLES[Piece.WHITE_QUEEN] = ZERO_WEIGHTING;
    	PIECE_SQUARE_TABLES[Piece.WHITE_ROOK] = ROOK_WHITE_WEIGHTINGS;
    	PIECE_SQUARE_TABLES[Piece.WHITE_BISHOP] = ZERO_WEIGHTING;
    	PIECE_SQUARE_TABLES[Piece.WHITE_KNIGHT] = KNIGHT_WHITE_WEIGHTINGS;
    	
    	PIECE_SQUARE_TABLES[Piece.BLACK_PAWN] = PAWN_BLACK_WEIGHTINGS;
    	PIECE_SQUARE_TABLES[Piece.BLACK_KING] = KING_BLACK_MIDGAME_WEIGHTINGS;
    	PIECE_SQUARE_TABLES[Piece.BLACK_QUEEN] = ZERO_WEIGHTING;
    	PIECE_SQUARE_TABLES[Piece.BLACK_ROOK] = ROOK_BLACK_WEIGHTINGS;
    	PIECE_SQUARE_TABLES[Piece.BLACK_BISHOP] = ZERO_WEIGHTING;
    	PIECE_SQUARE_TABLES[Piece.BLACK_KNIGHT] = KNIGHT_BLACK_WEIGHTINGS;
    }
    
    static final byte [][] ENDGAME_PIECE_SQUARE_TABLES;
    static {
    	ENDGAME_PIECE_SQUARE_TABLES = new byte[15][128];
    	
    	ENDGAME_PIECE_SQUARE_TABLES[Piece.WHITE_PAWN] = PAWN_WHITE_ENDGAME_WEIGHTINGS;
    	ENDGAME_PIECE_SQUARE_TABLES[Piece.WHITE_KING] = KING_WHITE_ENDGAME_WEIGHTINGS;
    	ENDGAME_PIECE_SQUARE_TABLES[Piece.WHITE_QUEEN] = ZERO_WEIGHTING;
    	ENDGAME_PIECE_SQUARE_TABLES[Piece.WHITE_ROOK] = ZERO_WEIGHTING;
    	ENDGAME_PIECE_SQUARE_TABLES[Piece.WHITE_BISHOP] = ZERO_WEIGHTING;
    	ENDGAME_PIECE_SQUARE_TABLES[Piece.WHITE_KNIGHT] = KNIGHT_WHITE_WEIGHTINGS;
    	
    	ENDGAME_PIECE_SQUARE_TABLES[Piece.BLACK_PAWN] = PAWN_BLACK_ENDGAME_WEIGHTINGS;
    	ENDGAME_PIECE_SQUARE_TABLES[Piece.BLACK_KING] = KING_BLACK_ENDGAME_WEIGHTINGS;
    	ENDGAME_PIECE_SQUARE_TABLES[Piece.BLACK_QUEEN] = ZERO_WEIGHTING;
    	ENDGAME_PIECE_SQUARE_TABLES[Piece.BLACK_ROOK] = ZERO_WEIGHTING;
    	ENDGAME_PIECE_SQUARE_TABLES[Piece.BLACK_BISHOP] = ZERO_WEIGHTING;
    	ENDGAME_PIECE_SQUARE_TABLES[Piece.BLACK_KNIGHT] = KNIGHT_BLACK_WEIGHTINGS;
    }
	
	public static int convertChessmanToPiece(int chessman, boolean isWhite) {
		int eubosPiece = Piece.NONE;
		if (chessman==IntChessman.KNIGHT)
			eubosPiece = isWhite ? Piece.WHITE_KNIGHT : Piece.BLACK_KNIGHT;
		else if (chessman==IntChessman.BISHOP)
			eubosPiece = isWhite ? Piece.WHITE_BISHOP : Piece.BLACK_BISHOP;
		else if (chessman==IntChessman.ROOK)
			eubosPiece = isWhite? Piece.WHITE_ROOK : Piece.BLACK_ROOK;
		else if (chessman==IntChessman.QUEEN)
			eubosPiece = isWhite ? Piece.WHITE_QUEEN : Piece.BLACK_QUEEN;
		return eubosPiece;
	}
	
	public static int convertPieceToChessman(int piece) {
		int chessman = IntChessman.NOCHESSMAN;
		if (Piece.isKnight(piece))
			chessman = IntChessman.KNIGHT;
		else if (Piece.isBishop(piece))
			chessman = IntChessman.BISHOP;
		else if (Piece.isRook(piece))
			chessman = IntChessman.ROOK;
		else if (Piece.isQueen(piece))
			chessman = IntChessman.QUEEN;
		else if (Piece.isKing(piece))
			chessman = IntChessman.KING;
		else if (Piece.isPawn(piece))
			chessman = IntChessman.PAWN;		
		return chessman;
	}
	
	public static char toFenChar(int piece) {
		char chessman = 0;
		if (piece==Piece.WHITE_PAWN)
			chessman = 'P';
		else if (piece==Piece.WHITE_KNIGHT)
			chessman = 'N';
		else if (piece==Piece.WHITE_BISHOP)
			chessman = 'B';
		else if (piece==Piece.WHITE_ROOK)
			chessman = 'R';
		else if (piece==Piece.WHITE_QUEEN)
			chessman = 'Q';
		else if (piece==Piece.WHITE_KING)
			chessman = 'K';
		else if (piece==Piece.BLACK_PAWN)
			chessman = 'p';
		else if (piece==Piece.BLACK_KNIGHT)
			chessman = 'n';
		else if (piece==Piece.BLACK_BISHOP)
			chessman = 'b';
		else if (piece==Piece.BLACK_ROOK)
			chessman = 'r';
		else if (piece==Piece.BLACK_QUEEN)
			chessman = 'q';
		else if (piece==Piece.BLACK_KING)
			chessman = 'k';
		return chessman;
	}
	
	public static String reportStaticDataSizes() {
		StringBuilder s = new StringBuilder();
		s.append(String.format("KnightMove_Lut_Size %d bytes\n", KnightMove_Lut_Size*4));
		s.append(String.format("KingMove_Lut_Size %d bytes\n", KingMove_Lut_Size*4));
		s.append(String.format("QueenMove_Lut_Size %d bytes\n", QueenMove_Lut_Size*4));
		s.append(String.format("RookMove_Lut_Size %d bytes\n", RookMove_Lut_Size*4));
		s.append(String.format("BishopMove_Lut_Size %d bytes\n", BishopMove_Lut_Size*4));
		return s.toString();
	}
	
	public static int getStaticDataSize() {
		return (KnightMove_Lut_Size + KingMove_Lut_Size + QueenMove_Lut_Size + RookMove_Lut_Size + BishopMove_Lut_Size) * 4;
	}
	
	static int KnightMove_Lut_Size = 0;
	static final int[][] WhiteKnightMove_Lut = new int[128][];
	static {
		for (int square : Position.values) {
			WhiteKnightMove_Lut[square] = createKnightMovesFromOriginPosition(square, true);
		}
	}
	static final int[][] BlackKnightMove_Lut = new int[128][];
	static {
		for (int square : Position.values) {
			BlackKnightMove_Lut[square] = createKnightMovesFromOriginPosition(square, false);
		}
	}
	static int [] createKnightMovesFromOriginPosition(int originPosition, boolean isWhite) {
		int originPiece = isWhite ? Piece.WHITE_KNIGHT : Piece.BLACK_KNIGHT;
		int count = 0;
		int [] moves = new int[8];
		// Create reference moves (with target none)
		for (Direction dir: Direction.values()) {
			int targetPosition = Direction.getIndirectMoveSq(dir, originPosition);
			if (targetPosition != Position.NOPOSITION) {
				moves[count] = Move.valueOf(originPosition, originPiece, targetPosition, Piece.NONE);
				count++;
			}
		}
		// Copy to correctly sized array
		int [] ref_moves = Arrays.copyOf(moves, count);
		KnightMove_Lut_Size += ref_moves.length;
		return ref_moves;
	}
	
	static int KingMove_Lut_Size = 0;
	static final int[][] WhiteKingMove_Lut = new int[128][];
	static {
		for (int square : Position.values) {
			WhiteKingMove_Lut[square] = createKingMovesFromOriginPosition(square, true);
		}
	}
	static final int[][] BlackKingMove_Lut = new int[128][];
	static {
		for (int square : Position.values) {
			BlackKingMove_Lut[square] = createKingMovesFromOriginPosition(square, false);
		}
	}
	static int [] createKingMovesFromOriginPosition(int originPosition, boolean isWhite) {
		Direction [] allDirect = { Direction.up, Direction.upRight, Direction.right, Direction.downRight, Direction.down, Direction.downLeft, Direction.left, Direction.upLeft };
		int originPiece = isWhite ? Piece.WHITE_KING : Piece.BLACK_KING;
		int count = 0;
		int [] moves = new int[8];
		// Create reference moves (with target none)
		for (Direction dir: allDirect) {
			int targetPosition = Direction.getDirectMoveSq(dir, originPosition);
			if (targetPosition != Position.NOPOSITION) {
				moves[count] = Move.valueOf(originPosition, originPiece, targetPosition, Piece.NONE);
				count++;
			}
		}
		// Copy to correctly sized array
		int [] ref_moves = Arrays.copyOf(moves, count);
		KingMove_Lut_Size += ref_moves.length;
		return ref_moves;
	}
	
	static final int[][] BlackPawnPromotionMove_Lut = new int[128][];
	static {
		for (int square : Position.values) {
			if (Position.getRank(square) == IntRank.R2) {
				BlackPawnPromotionMove_Lut[square] = createBlackPawnPromotionMovesFromOriginPosition(square);
			}
		}
	}
	static int [] createBlackPawnPromotionMovesFromOriginPosition(int originPosition) {
		int originPiece = Piece.BLACK_PAWN;
		int [] moves = new int[4];
		// Create reference moves (with target none)
		int targetPosition = Direction.getDirectMoveSq(Direction.down, originPosition);
		moves[0] = Move.valueOf(Move.TYPE_PROMOTION_MASK, originPosition, originPiece, targetPosition, Piece.NONE, Piece.QUEEN );
		moves[1] = Move.valueOf(Move.TYPE_PROMOTION_MASK, originPosition, originPiece, targetPosition, Piece.NONE, Piece.ROOK );
		moves[2] = Move.valueOf(Move.TYPE_PROMOTION_MASK, originPosition, originPiece, targetPosition, Piece.NONE, Piece.BISHOP );
		moves[3] = Move.valueOf(Move.TYPE_PROMOTION_MASK, originPosition, originPiece, targetPosition, Piece.NONE, Piece.KNIGHT );
		return moves;
	}
	
	static final int[][] WhitePawnPromotionMove_Lut = new int[128][];
	static {
		for (int square : Position.values) {
			if (Position.getRank(square) == IntRank.R7) {
				WhitePawnPromotionMove_Lut[square] = createWhitePawnPromotionMovesFromOriginPosition(square);
			}
		}
	}
	static int [] createWhitePawnPromotionMovesFromOriginPosition(int originPosition) {
		int originPiece = Piece.WHITE_PAWN;
		int [] moves = new int[4];
		// Create reference moves (with target none)
		int targetPosition = Direction.getDirectMoveSq(Direction.up, originPosition);
		moves[0] = Move.valueOf(Move.TYPE_PROMOTION_MASK, originPosition, originPiece, targetPosition, Piece.NONE, Piece.QUEEN );
		moves[1] = Move.valueOf(Move.TYPE_PROMOTION_MASK, originPosition, originPiece, targetPosition, Piece.NONE, Piece.ROOK );
		moves[2] = Move.valueOf(Move.TYPE_PROMOTION_MASK, originPosition, originPiece, targetPosition, Piece.NONE, Piece.BISHOP );
		moves[3] = Move.valueOf(Move.TYPE_PROMOTION_MASK, originPosition, originPiece, targetPosition, Piece.NONE, Piece.KNIGHT );
		return moves;
	}
	
	static int RookMove_Lut_Size = 0;
	static final int[][][] WhiteRookMove_Lut = new int[128][][]; // Position by direction by moves in that direction
	static {
		for (int square : Position.values) {
			WhiteRookMove_Lut[square] = createRookMovesFromOriginPosition(square, true);
		}
	}
	static final int[][][] BlackRookMove_Lut = new int[128][][];
	static {
		for (int square : Position.values) {
			BlackRookMove_Lut[square] = createRookMovesFromOriginPosition(square, false);
		}
	}
	static int [][] createRookMovesFromOriginPosition(int originPosition, boolean isWhite) {
		Direction [] rookDirect = SquareAttackEvaluator.rankFile;
		int originPiece = isWhite ? Piece.WHITE_ROOK: Piece.BLACK_ROOK;
		int [][] return_value = new int [4][];
		int direction_index = 0;
		// Create reference moves (with target none)
		for (Direction dir : rookDirect) {
			int count = 0;
			int [] moves = new int[7];
			// Walk down direction adding all squares to the edge of the board
			int targetPosition = Direction.getDirectMoveSq(dir, originPosition);
			while (targetPosition != Position.NOPOSITION) {
				if (targetPosition != Position.NOPOSITION) {
					moves[count] = Move.valueOf(originPosition, originPiece, targetPosition, Piece.NONE);
					count++;
				}
				targetPosition = Direction.getDirectMoveSq(dir, targetPosition);
			}
			// Copy to correctly sized array
			int [] ref_moves = Arrays.copyOf(moves, count);
			return_value[direction_index++] = ref_moves;
			RookMove_Lut_Size += ref_moves.length;
		}
		return return_value;
	}
	
	static int BishopMove_Lut_Size = 0;
	static final int[][][] WhiteBishopMove_Lut = new int[128][][]; // Position by direction by moves in that direction
	static {
		for (int square : Position.values) {
			WhiteBishopMove_Lut[square] = createBishopMovesFromOriginPosition(square, true);
		}
	}
	static final int[][][] BlackBishopMove_Lut = new int[128][][];
	static {
		for (int square : Position.values) {
			BlackBishopMove_Lut[square] = createBishopMovesFromOriginPosition(square, false);
		}
	}
	static int [][] createBishopMovesFromOriginPosition(int originPosition, boolean isWhite) {
		Direction [] bishopDirect = SquareAttackEvaluator.diagonals;
		int originPiece = isWhite ? Piece.WHITE_BISHOP: Piece.BLACK_BISHOP;
		int [][] return_value = new int [4][];
		int direction_index = 0;
		// Create reference moves (with target none)
		for (Direction dir : bishopDirect) {
			int count = 0;
			int [] moves = new int[7];
			// Walk down direction adding all squares to the edge of the board
			int targetPosition = Direction.getDirectMoveSq(dir, originPosition);
			while (targetPosition != Position.NOPOSITION) {
				if (targetPosition != Position.NOPOSITION) {
					moves[count] = Move.valueOf(originPosition, originPiece, targetPosition, Piece.NONE);
					count++;
				}
				targetPosition = Direction.getDirectMoveSq(dir, targetPosition);
			}
			// Copy to correctly sized array
			int [] ref_moves = Arrays.copyOf(moves, count);
			return_value[direction_index++] = ref_moves;
			BishopMove_Lut_Size += ref_moves.length;
		}
		return return_value;
	}
	
	static int QueenMove_Lut_Size = 0;
	static final int[][][] WhiteQueenMove_Lut = new int[128][][]; // Position by direction by moves in that direction
	static {
		for (int square : Position.values) {
			WhiteQueenMove_Lut[square] = createQueenMovesFromOriginPosition(square, true);
		}
	}
	static final int[][][] BlackQueenMove_Lut = new int[128][][];
	static {
		for (int square : Position.values) {
			BlackQueenMove_Lut[square] = createQueenMovesFromOriginPosition(square, false);
		}
	}
	static int [][] createQueenMovesFromOriginPosition(int originPosition, boolean isWhite) {
		Direction [] queenDirect = SquareAttackEvaluator.allDirect;
		int originPiece = isWhite ? Piece.WHITE_QUEEN: Piece.BLACK_QUEEN;
		int [][] return_value = new int [8][];
		int direction_index = 0;
		// Create reference moves (with target none)
		for (Direction dir : queenDirect) {
			int count = 0;
			int [] moves = new int[7];
			// Walk down direction adding all squares to the edge of the board
			int targetPosition = Direction.getDirectMoveSq(dir, originPosition);
			while (targetPosition != Position.NOPOSITION) {
				if (targetPosition != Position.NOPOSITION) {
					moves[count] = Move.valueOf(originPosition, originPiece, targetPosition, Piece.NONE);
					count++;
				}
				targetPosition = Direction.getDirectMoveSq(dir, targetPosition);
			}
			// Copy to correctly sized array
			int [] ref_moves = Arrays.copyOf(moves, count);
			return_value[direction_index++] = ref_moves;
			QueenMove_Lut_Size += ref_moves.length;
		}
		return return_value;
	}
	
	static void king_generateMoves_White(IAddMoves ml, Board theBoard, int atSquare) {
		single_addMoves_White(ml, theBoard, WhiteKingMove_Lut[atSquare]);	
	}
	
	static void king_generateMoves_Black(IAddMoves ml, Board theBoard, int atSquare) {
		single_addMoves_Black(ml, theBoard, BlackKingMove_Lut[atSquare]);	
	}
	
	static void knight_generateMoves_White(IAddMoves ml, Board theBoard, int atSquare) {
		single_addMoves_White(ml, theBoard, WhiteKnightMove_Lut[atSquare]);
	}
	
	static void knight_generateMoves_Black(IAddMoves ml, Board theBoard, int atSquare) {
		single_addMoves_Black(ml, theBoard, BlackKnightMove_Lut[atSquare]);
	}
		
	static void king_generateMovesExtSearch_White(IAddMoves ml, Board theBoard, int atSquare) {
		single_addCaptures_White(ml, theBoard, WhiteKingMove_Lut[atSquare]);
	}
	
	static void king_generateMovesExtSearch_Black(IAddMoves ml, Board theBoard, int atSquare) {
		single_addCaptures_Black(ml, theBoard, BlackKingMove_Lut[atSquare]);
	}
		
	static void knight_generateMovesExtSearch_White(IAddMoves ml, Board theBoard, int atSquare) {
		single_addCaptures_White(ml, theBoard, WhiteKnightMove_Lut[atSquare]);
	}
	
	static void knight_generateMovesExtSearch_Black(IAddMoves ml, Board theBoard, int atSquare) {
		single_addCaptures_Black(ml, theBoard, BlackKnightMove_Lut[atSquare]);
	}
	
	static void rook_generateMoves_White(IAddMoves ml, Board theBoard, int atSquare) {
		multidirect_addMoves_White(ml, theBoard, WhiteRookMove_Lut[atSquare]);
	}
	
	static void rook_generateMoves_Black(IAddMoves ml, Board theBoard, int atSquare) {
		multidirect_addMoves_Black(ml, theBoard, BlackRookMove_Lut[atSquare]);
	}
	
	static void queen_generateMoves_White(IAddMoves ml, Board theBoard, int atSquare) {
		multidirect_addMoves_White(ml, theBoard, WhiteQueenMove_Lut[atSquare]);	
	}
	
	static void queen_generateMoves_Black(IAddMoves ml, Board theBoard, int atSquare) {
		multidirect_addMoves_Black(ml, theBoard, BlackQueenMove_Lut[atSquare]);	
	}
	
	static void bishop_generateMoves_White(IAddMoves ml, Board theBoard, int atSquare) {
		multidirect_addMoves_White(ml, theBoard, WhiteBishopMove_Lut[atSquare]);	
	}
	
	static void bishop_generateMoves_Black(IAddMoves ml, Board theBoard, int atSquare) {
		multidirect_addMoves_Black(ml, theBoard, BlackBishopMove_Lut[atSquare]);	
	}
		
	static void rook_generateMovesExtSearch_Black(IAddMoves ml, Board theBoard, int atSquare) {
		multidirect_addCapturesForBlack(ml, theBoard, BlackRookMove_Lut[atSquare]);
	}
	
	static void queen_generateMovesExtSearch_Black(IAddMoves ml, Board theBoard, int atSquare) {
		multidirect_addCapturesForBlack(ml, theBoard, BlackQueenMove_Lut[atSquare]);	
	}
	
	static void bishop_generateMovesExtSearch_Black(IAddMoves ml, Board theBoard, int atSquare) {
		multidirect_addCapturesForBlack(ml, theBoard, BlackBishopMove_Lut[atSquare]);	
	}
	
	static void rook_generateMovesExtSearch_White(IAddMoves ml, Board theBoard, int atSquare) {
		multidirect_addCapturesForWhite(ml, theBoard, WhiteRookMove_Lut[atSquare]);
	}
	
	static void queen_generateMovesExtSearch_White(IAddMoves ml, Board theBoard, int atSquare) {
		multidirect_addCapturesForWhite(ml, theBoard, WhiteQueenMove_Lut[atSquare]);	
	}
	
	static void bishop_generateMovesExtSearch_White(IAddMoves ml, Board theBoard, int atSquare) {
		multidirect_addCapturesForWhite(ml, theBoard, WhiteBishopMove_Lut[atSquare]);	
	}

	private static void multidirect_addMoves_White(IAddMoves ml, Board theBoard, int[][] moves) {
		ml.clearAttackedCache();
		for (int[] movesInDirection : moves) {
			for (int new_move : movesInDirection) {
				int targetPiece = theBoard.getPieceAtSquareEnemyBlack(Move.getTargetPosition(new_move));
				switch(targetPiece) {
				case Piece.NONE:
					ml.addNormal(new_move);
					continue;
				case Piece.DONT_CARE:
					break; // i.e. blocked by own piece
				default:
					new_move = Move.setCapture(new_move, targetPiece);
					ml.addPrio(new_move);
					break;
				}
				break;
			}	
		}
	}
	
	private static void multidirect_addMoves_Black(IAddMoves ml, Board theBoard, int[][] moves) {
		ml.clearAttackedCache();
		for (int[] movesInDirection : moves) {
			for (int new_move : movesInDirection) {
				int targetPiece = theBoard.getPieceAtSquareEnemyWhite(Move.getTargetPosition(new_move));
				switch(targetPiece) {
				case Piece.NONE:
					ml.addNormal(new_move);
					continue;
				case Piece.DONT_CARE:
					break; // i.e. blocked by own piece
				default:
					new_move = Move.setCapture(new_move, targetPiece);
					ml.addPrio(new_move);
					break;
				}
				break;
			}	
		}
	}
	
	private static void multidirect_addCapturesForBlack(IAddMoves ml, Board theBoard, int[][] moves) {
		ml.clearAttackedCache();
		for (int[] movesInDirection : moves) {
			for (int new_move : movesInDirection) {
				int targetPiece = theBoard.getPieceAtSquareEnemyWhite(Move.getTargetPosition(new_move));
				switch(targetPiece) {
				case Piece.NONE:
					continue;
				case Piece.DONT_CARE:
					break; // i.e. blocked by own piece
				default:
					new_move = Move.setCapture(new_move, targetPiece);
					ml.addPrio(new_move);
					break;
				}
				break;
			}
		}
	}
	
	private static void multidirect_addCapturesForWhite(IAddMoves ml, Board theBoard, int[][] moves) {
		ml.clearAttackedCache();
		for (int[] movesInDirection : moves) {
			for (int new_move : movesInDirection) {
				int targetPiece = theBoard.getPieceAtSquareEnemyBlack(Move.getTargetPosition(new_move));
				switch(targetPiece) {
				case Piece.NONE:
					continue;
				case Piece.DONT_CARE:
					break; // i.e. blocked by own piece
				default:
					new_move = Move.setCapture(new_move, targetPiece);
					ml.addPrio(new_move);
					break;
				}
				break;
			}
		}
	}
	
	private static void single_addMoves_White(IAddMoves ml, Board theBoard, int[] moves) {
		ml.clearAttackedCache();
		for (int new_move : moves) {
			int targetPiece = theBoard.getPieceAtSquareEnemyBlack(Move.getTargetPosition(new_move));
			switch(targetPiece) {
			case Piece.NONE:
				ml.addNormal(new_move);
				continue;
			case Piece.DONT_CARE:
				break; // i.e. blocked by own piece
			default:
				new_move = Move.setCapture(new_move, targetPiece);
				ml.addPrio(new_move);
				break;
			}
		}
	}
	
	private static void single_addMoves_Black(IAddMoves ml, Board theBoard, int[] moves) {
		ml.clearAttackedCache();
		for (int new_move : moves) {
			int targetPiece = theBoard.getPieceAtSquareEnemyWhite(Move.getTargetPosition(new_move));
			switch(targetPiece) {
			case Piece.NONE:
				ml.addNormal(new_move);
				continue;
			case Piece.DONT_CARE:
				break; // i.e. blocked by own piece
			default:
				new_move = Move.setCapture(new_move, targetPiece);
				ml.addPrio(new_move);
				break;
			}
		}
	}
	
	private static void single_addCaptures_White(IAddMoves ml, Board theBoard, int[] moves) {
		ml.clearAttackedCache();
		for (int new_move : moves) {
			int targetPiece = theBoard.getPieceAtSquareEnemyBlack(Move.getTargetPosition(new_move));
			switch(targetPiece) {
			case Piece.NONE:
				continue;
			case Piece.DONT_CARE:
				break; // i.e. blocked by own piece
			default:
				new_move = Move.setCapture(new_move, targetPiece);
				ml.addPrio(new_move);
				break;
			}
		}
	}
	
	private static void single_addCaptures_Black(IAddMoves ml, Board theBoard, int[] moves) {
		ml.clearAttackedCache();
		for (int new_move : moves) {
			int targetPiece = theBoard.getPieceAtSquareEnemyWhite(Move.getTargetPosition(new_move));
			switch(targetPiece) {
			case Piece.NONE:
				continue;
			case Piece.DONT_CARE:
				break; // i.e. blocked by own piece
			default:
				new_move = Move.setCapture(new_move, targetPiece);
				ml.addPrio(new_move);
				break;
			}
		}
	}
	
	private static int pawn_genOneSqTargetWhite(int atSquare) {
		return atSquare+16;
	}
	private static int pawn_genOneSqTargetBlack(int atSquare) {
		return atSquare-16;
	}	
	
	private static int pawn_genTwoSqTargetWhite(int atSquare) {
		int moveTo = Position.NOPOSITION;
		if (Position.getRank(atSquare) == IntRank.R2) {
			// bound checking is implicit from start position check
			moveTo = atSquare+32;
		}
		return moveTo;
	}
	
	private static int pawn_genTwoSqTargetBlack(int atSquare) {
		int moveTo = Position.NOPOSITION;
		if (Position.getRank(atSquare) == IntRank.R7) {
			// bound checking is implicit from start position check
			moveTo = atSquare-32;
		}
		return moveTo;
	}
	
	private static int pawn_genLeftCaptureTargetWhite(int atSquare) {
		// Needs off board check
		return Direction.getDirectMoveSq(Direction.upLeft, atSquare);
	}
	
	private static int pawn_genRightCaptureTargetWhite(int atSquare) {
		// Needs off board check
		return Direction.getDirectMoveSq(Direction.upRight, atSquare);	
	}
	
	private static int pawn_isCapturableWhite(Board theBoard, int captureAt) {
		int capturePiece = Piece.NONE;
		int queryPiece = theBoard.getPieceAtSquareEnemyBlack(captureAt);
		if (queryPiece != Piece.NONE && queryPiece != Piece.DONT_CARE) {
			capturePiece = queryPiece;
		}
		return capturePiece;
	}
	
	private static boolean pawn_checkPromotionPossibleWhite(int targetSquare ) {
		return Position.getRank(targetSquare) == IntRank.R8;
	}
	
	private static void pawn_checkPromotionAddMoveWhite(int atSquare, IAddMoves ml, int targetSquare) {
		if (pawn_checkPromotionPossibleWhite(targetSquare)) {
			ml.addPrio(WhitePawnPromotionMove_Lut[atSquare][0]);
		} else {
			ml.addNormal(Move.valueOf(atSquare, Piece.WHITE_PAWN, targetSquare, Piece.NONE));
		}
	}
	
	private static void pawn_checkPromotionAddCaptureMoveWhite(int ownPiece, int atSquare, IAddMoves ml,	int targetSquare, int targetPiece) {
		if (pawn_checkPromotionPossibleWhite(targetSquare)) {
			ml.addPrio(Move.valueOf(Move.TYPE_PROMOTION_MASK, atSquare, ownPiece, targetSquare, targetPiece, Piece.QUEEN ));
		} else {
			ml.addPrio(Move.valueOf(atSquare, ownPiece, targetSquare, targetPiece));
		}
	}
	
	private static int pawn_genLeftCaptureTargetBlack(int atSquare) {
		// Needs off board check
		return Direction.getDirectMoveSq(Direction.downRight, atSquare);
	}
	
	private static int pawn_genRightCaptureTargetBlack(int atSquare) {
		// Needs off board check
		return Direction.getDirectMoveSq(Direction.downLeft, atSquare);	
	}
	
	private static int pawn_isCapturableBlack(Board theBoard, int captureAt ) {
		int capturePiece = Piece.NONE;
		int queryPiece = theBoard.getPieceAtSquareEnemyWhite(captureAt);
		if (queryPiece != Piece.NONE && queryPiece != Piece.DONT_CARE) {
			capturePiece = queryPiece;
		}
		return capturePiece;
	}
	
	private static boolean pawn_checkPromotionPossibleBlack(int targetSquare ) {
		return Position.getRank(targetSquare) == IntRank.R1;
	}
	
	private static void pawn_checkPromotionAddMoveBlack(int atSquare, IAddMoves ml, int targetSquare) {
		if (pawn_checkPromotionPossibleBlack(targetSquare)) {
			ml.addPrio(BlackPawnPromotionMove_Lut[atSquare][0]);
		} else {
			ml.addNormal(Move.valueOf(atSquare, Piece.BLACK_PAWN, targetSquare, Piece.NONE));
		}
	}
	
	private static void pawn_checkPromotionAddCaptureMoveBlack(int ownPiece, int atSquare, IAddMoves ml,
			int targetSquare, int targetPiece) {
		if (pawn_checkPromotionPossibleBlack(targetSquare)) {
			ml.addPrio(Move.valueOf(Move.TYPE_PROMOTION_MASK, atSquare, ownPiece, targetSquare, targetPiece, Piece.QUEEN ));
		} else {
			ml.addPrio(Move.valueOf(atSquare, ownPiece, targetSquare, targetPiece));
		}
	}
	
	static void pawn_generateMoves_White(IAddMoves ml, Board theBoard, int atSquare) {
		ml.clearAttackedCache();
		int ownPiece = Piece.WHITE_PAWN;
		int capturePiece = Piece.NONE;
		// Check for standard one and two square moves
		int moveTo = pawn_genOneSqTargetWhite(atSquare);
		if (theBoard.squareIsEmpty(moveTo)) {
			pawn_checkPromotionAddMoveWhite(atSquare, ml, moveTo);
			moveTo = pawn_genTwoSqTargetWhite(atSquare);
			if (moveTo != Position.NOPOSITION && theBoard.squareIsEmpty(moveTo)) {
				// Can't be a promotion or capture
				ml.addNormal(Move.valueOf(atSquare, ownPiece, moveTo , Piece.NONE));
			}	
		}
		// Check for capture moves, includes en passant
		int captureAt = pawn_genLeftCaptureTargetWhite(atSquare);
		if (captureAt != Position.NOPOSITION) {
			capturePiece = pawn_isCapturableWhite(theBoard, captureAt);
			if (capturePiece != Piece.NONE) {
				pawn_checkPromotionAddCaptureMoveWhite(ownPiece, atSquare, ml, captureAt, capturePiece);
			} else if (captureAt == theBoard.getEnPassantTargetSq()) {
				capturePiece = Piece.BLACK_PAWN;
				// promotion can't be possible if en passant capture
				ml.addPrio(Move.valueOfEnPassant(Move.MISC_EN_PASSANT_CAPTURE_MASK, 0, atSquare, ownPiece, captureAt, capturePiece, Piece.NONE));
			}
		}
		captureAt = pawn_genRightCaptureTargetWhite(atSquare);
		if ( captureAt != Position.NOPOSITION ) {
			capturePiece = pawn_isCapturableWhite(theBoard, captureAt);
			if (capturePiece != Piece.NONE) {
				pawn_checkPromotionAddCaptureMoveWhite(ownPiece, atSquare, ml, captureAt, capturePiece);
			} else if (captureAt == theBoard.getEnPassantTargetSq()) {
				capturePiece = Piece.BLACK_PAWN;
				// promotion can't be possible if en passant capture
				ml.addPrio(Move.valueOfEnPassant(Move.MISC_EN_PASSANT_CAPTURE_MASK, 0, atSquare, ownPiece, captureAt, capturePiece, Piece.NONE));
			}
		}
	}
	
	static void pawn_generateMoves_Black(IAddMoves ml, Board theBoard, int atSquare) {
		ml.clearAttackedCache();
		int ownPiece = Piece.BLACK_PAWN;
		int capturePiece = Piece.NONE;
		// Check for standard one and two square moves
		int moveTo = pawn_genOneSqTargetBlack(atSquare);
		if (theBoard.squareIsEmpty(moveTo)) {
			pawn_checkPromotionAddMoveBlack(atSquare, ml, moveTo);
			moveTo = pawn_genTwoSqTargetBlack(atSquare);
			if (moveTo != Position.NOPOSITION && theBoard.squareIsEmpty(moveTo)) {
				// Can't be a promotion or capture
				ml.addNormal(Move.valueOf(atSquare, ownPiece, moveTo , Piece.NONE));
			}	
		}
		// Check for capture moves, includes en passant
		int captureAt = pawn_genLeftCaptureTargetBlack(atSquare);
		if (captureAt != Position.NOPOSITION) {
			capturePiece = pawn_isCapturableBlack(theBoard, captureAt);
			if (capturePiece != Piece.NONE) {
				pawn_checkPromotionAddCaptureMoveBlack(ownPiece, atSquare, ml, captureAt, capturePiece);
			} else if (captureAt == theBoard.getEnPassantTargetSq()) {
				capturePiece = Piece.WHITE_PAWN;
				// promotion can't be possible if en passant capture
				ml.addPrio(Move.valueOfEnPassant(Move.MISC_EN_PASSANT_CAPTURE_MASK, 0, atSquare, ownPiece, captureAt, capturePiece, Piece.NONE));
			}
		}
		captureAt = pawn_genRightCaptureTargetBlack(atSquare);
		if ( captureAt != Position.NOPOSITION ) {
			capturePiece = pawn_isCapturableBlack(theBoard, captureAt);
			if (capturePiece != Piece.NONE) {
				pawn_checkPromotionAddCaptureMoveBlack(ownPiece, atSquare, ml, captureAt, capturePiece);
			} else if (captureAt == theBoard.getEnPassantTargetSq()) {
				capturePiece = Piece.WHITE_PAWN;
				// promotion can't be possible if en passant capture
				ml.addPrio(Move.valueOfEnPassant(Move.MISC_EN_PASSANT_CAPTURE_MASK, 0, atSquare, ownPiece, captureAt, capturePiece, Piece.NONE));
			}
		}
	}
	
	static void pawn_generateMovesForExtendedSearch_White(IAddMoves ml, Board theBoard, int atSquare) {
		ml.clearAttackedCache();
		// Standard move
		int moveTo = pawn_genOneSqTargetWhite(atSquare);
		if (pawn_checkPromotionPossibleWhite(moveTo) && theBoard.squareIsEmpty(moveTo)) {
			ml.addPrio(WhitePawnPromotionMove_Lut[atSquare][0]);
		}
		// Capture moves
		int ownPiece = Piece.WHITE_PAWN;
		int capturePiece = Piece.NONE;
		int captureAt = pawn_genLeftCaptureTargetWhite(atSquare);
		if (captureAt != Position.NOPOSITION) {
			capturePiece = pawn_isCapturableWhite(theBoard, captureAt);
			if (capturePiece != Piece.NONE) {
				pawn_checkPromotionAddCaptureMoveWhite(ownPiece, atSquare, ml, captureAt, capturePiece);
			} else if (captureAt == theBoard.getEnPassantTargetSq()) {
				capturePiece = Piece.BLACK_PAWN;
				// promotion can't be possible if en passant capture
				ml.addPrio(Move.valueOfEnPassant(Move.MISC_EN_PASSANT_CAPTURE_MASK, 0, atSquare, ownPiece, captureAt, capturePiece, Piece.NONE));
			}
		}
		captureAt = pawn_genRightCaptureTargetWhite(atSquare);
		if (captureAt != Position.NOPOSITION) {
			capturePiece = pawn_isCapturableWhite(theBoard, captureAt);
			if (capturePiece != Piece.NONE) {
				pawn_checkPromotionAddCaptureMoveWhite(ownPiece, atSquare, ml, captureAt, capturePiece);
			} else if (captureAt == theBoard.getEnPassantTargetSq()) {
				capturePiece = Piece.BLACK_PAWN;
				// promotion can't be possible if en passant capture
				ml.addPrio(Move.valueOfEnPassant(Move.MISC_EN_PASSANT_CAPTURE_MASK, 0, atSquare, ownPiece, captureAt, capturePiece, Piece.NONE));
			}
		}
	}
	
	static void pawn_generateMovesForExtendedSearch_Black(IAddMoves ml, Board theBoard, int atSquare) {
		ml.clearAttackedCache();
		// Standard move
		int moveTo = pawn_genOneSqTargetBlack(atSquare);
		if (pawn_checkPromotionPossibleBlack(moveTo) && theBoard.squareIsEmpty(moveTo)) {
			ml.addPrio(BlackPawnPromotionMove_Lut[atSquare][0]);
		}
		// Capture moves
		int ownPiece = Piece.BLACK_PAWN;
		int capturePiece = Piece.NONE;
		int captureAt = pawn_genLeftCaptureTargetBlack(atSquare);
		if (captureAt != Position.NOPOSITION) {
			capturePiece = pawn_isCapturableBlack(theBoard, captureAt);
			if (capturePiece != Piece.NONE) {
				pawn_checkPromotionAddCaptureMoveBlack(ownPiece, atSquare, ml, captureAt, capturePiece);
			} else if (captureAt == theBoard.getEnPassantTargetSq()) {
				capturePiece = Piece.WHITE_PAWN;
				// promotion can't be possible if en passant capture
				ml.addPrio(Move.valueOfEnPassant(Move.MISC_EN_PASSANT_CAPTURE_MASK, 0, atSquare, ownPiece, captureAt, capturePiece, Piece.NONE));
			}
		}
		captureAt = pawn_genRightCaptureTargetBlack(atSquare);
		if (captureAt != Position.NOPOSITION) {
			capturePiece = pawn_isCapturableBlack(theBoard, captureAt);
			if (capturePiece != Piece.NONE) {
				pawn_checkPromotionAddCaptureMoveBlack(ownPiece, atSquare, ml, captureAt, capturePiece);
			} else if (captureAt == theBoard.getEnPassantTargetSq()) {
				capturePiece = Piece.WHITE_PAWN;
				// promotion can't be possible if en passant capture
				ml.addPrio(Move.valueOfEnPassant(Move.MISC_EN_PASSANT_CAPTURE_MASK, 0, atSquare, ownPiece, captureAt, capturePiece, Piece.NONE));
			}
		}
	}
	
	static void pawn_generatePromotionMoves_White(IAddMoves ml, Board theBoard, int atSquare) {
		ml.clearAttackedCache();
		// Standard move
		int moveTo = pawn_genOneSqTargetWhite(atSquare);
		if (pawn_checkPromotionPossibleWhite(moveTo) && theBoard.squareIsEmpty(moveTo)) {
			ml.addPrio(WhitePawnPromotionMove_Lut[atSquare][0]);
		}
		// Capture moves
		int ownPiece = Piece.WHITE_PAWN;
		int capturePiece = Piece.NONE;
		int captureAt = pawn_genLeftCaptureTargetWhite(atSquare);
		if (captureAt != Position.NOPOSITION) {
			capturePiece = pawn_isCapturableWhite(theBoard, captureAt);
			if (capturePiece != Piece.NONE) {
				ml.addPrio(Move.valueOf(Move.TYPE_PROMOTION_MASK, atSquare, ownPiece, captureAt, capturePiece, Piece.QUEEN ));
			}
		}
		captureAt = pawn_genRightCaptureTargetWhite(atSquare);
		if (captureAt != Position.NOPOSITION) {
			capturePiece = pawn_isCapturableWhite(theBoard, captureAt);
			if (capturePiece != Piece.NONE) {
				ml.addPrio(Move.valueOf(Move.TYPE_PROMOTION_MASK, atSquare, ownPiece, captureAt, capturePiece, Piece.QUEEN ));
			}
		}
	}
	
	static void pawn_generatePromotionMoves_Black(IAddMoves ml, Board theBoard, int atSquare) {
		ml.clearAttackedCache();
		// Standard move
		int moveTo = pawn_genOneSqTargetBlack(atSquare);
		if (pawn_checkPromotionPossibleBlack(moveTo) && theBoard.squareIsEmpty(moveTo)) {
			ml.addPrio(BlackPawnPromotionMove_Lut[atSquare][0]);
		}
		// Capture moves
		int ownPiece = Piece.BLACK_PAWN;
		int capturePiece = Piece.NONE;
		int captureAt = pawn_genLeftCaptureTargetBlack(atSquare);
		if (captureAt != Position.NOPOSITION) {
			capturePiece = pawn_isCapturableBlack(theBoard, captureAt);
			if (capturePiece != Piece.NONE) {
				ml.addPrio(Move.valueOf(Move.TYPE_PROMOTION_MASK, atSquare, ownPiece, captureAt, capturePiece, Piece.QUEEN ));
			}
		}
		captureAt = pawn_genRightCaptureTargetBlack(atSquare);
		if (captureAt != Position.NOPOSITION) {
			capturePiece = pawn_isCapturableBlack(theBoard, captureAt);
			if (capturePiece != Piece.NONE) {
				ml.addPrio(Move.valueOf(Move.TYPE_PROMOTION_MASK, atSquare, ownPiece, captureAt, capturePiece, Piece.QUEEN ));
			}
		}
	}
}
