package eubos.board;

import java.util.Arrays;

import com.fluxchess.jcpi.models.IntChessman;
import com.fluxchess.jcpi.models.IntRank;

import eubos.main.EubosEngineMain;
import eubos.position.IAddMoves;
import eubos.position.Move;
import eubos.position.Position;

public abstract class Piece {
    public enum Colour { 
        white, black;
        
        public static Colour getOpposite( Colour arg ) { return (arg == white) ? black : white; }
        public static boolean isWhite( Colour arg ) { return arg == white; }
        public static boolean isBlack( Colour arg ) { return arg == black; }
    };
    
    // Note: Piece values below are not completely arbitrary, they must match Zobrist indexes
    public static final int NONE = 0x0;
    public static final int QUEEN = 0x1;
    public static final int ROOK = 0x2;
    public static final int BISHOP = 0x3;
    public static final int KNIGHT = 0x4;
    public static final int KING = 0x5;
    public static final int PAWN = 0x6;
    public static final int DONT_CARE = 0x7;
    
    public static final int BLACK = 0x8;
    public static final int COLOUR_BIT_SHIFT = 3;
    
    public static final int PIECE_NO_COLOUR_MASK = 0x7;
    public static final int PIECE_WHOLE_MASK = 0xf;

    public static final int WHITE_QUEEN = QUEEN;
    public static final int WHITE_BISHOP = BISHOP;
    public static final int WHITE_KING = KING;
    public static final int WHITE_KNIGHT = KNIGHT;
    public static final int WHITE_ROOK = ROOK;
    public static final int WHITE_PAWN = PAWN;
    
    public static final int BLACK_QUEEN = (BLACK|QUEEN);
    public static final int BLACK_BISHOP = (BLACK|BISHOP);
    public static final int BLACK_KING = (BLACK|KING);
    public static final int BLACK_KNIGHT = (BLACK|KNIGHT);
    public static final int BLACK_ROOK = (BLACK|ROOK);
    public static final int BLACK_PAWN = (BLACK|PAWN);
    public static final int PIECE_LENGTH = (BLACK|DONT_CARE);
    
    public static boolean isPawn(int arg) { return (arg & PIECE_NO_COLOUR_MASK) == PAWN; }
    public static boolean isKing(int arg) { return (arg & PIECE_NO_COLOUR_MASK) == KING; }
    public static boolean isQueen(int arg) { return (arg & PIECE_NO_COLOUR_MASK) == QUEEN; }
    public static boolean isRook(int arg) { return (arg & PIECE_NO_COLOUR_MASK) == ROOK; }
    public static boolean isBishop(int arg) { return (arg & PIECE_NO_COLOUR_MASK) == BISHOP; }
    public static boolean isKnight(int arg) { return (arg & PIECE_NO_COLOUR_MASK) == KNIGHT; }
    
    public static boolean isOppositeColour(Colour ownColour, int toCheck) {
        if (EubosEngineMain.ENABLE_ASSERTS)
            assert (toCheck & PIECE_NO_COLOUR_MASK) != NONE;
        return Colour.isWhite(ownColour) ? isBlack(toCheck) : isWhite(toCheck);
    }
    public static boolean isOppositeColourOrNone(Colour ownColour, int toCheck) {
        boolean retVal = true;
        if (toCheck != Piece.NONE) {
            retVal = Colour.isWhite(ownColour) ? isBlack(toCheck) : isWhite(toCheck);
        }
        return retVal;
    }
    public static boolean isWhite(int arg) {
        return (arg&BLACK) == 0;
    }
    public static boolean isBlack(int arg) {
        return (arg&BLACK) == BLACK;
    }
    public static Colour getOpposite(int arg) {
        return isWhite(arg) ? Colour.black : Colour.white;
    } 
    
    public static final short MATERIAL_VALUE_KING = 4000;
    public static final short MATERIAL_VALUE_QUEEN = 1800;
    public static final short MATERIAL_VALUE_ROOK = 900;
    public static final short MATERIAL_VALUE_BISHOP = 600;
    public static final short MATERIAL_VALUE_KNIGHT = 580;
    public static final short MATERIAL_VALUE_PAWN = 100;
    
    public static final short EG_MATERIAL_VALUE_KING = 4000;
    public static final short EG_MATERIAL_VALUE_QUEEN = 1560;
    public static final short EG_MATERIAL_VALUE_ROOK = 845;
    public static final short EG_MATERIAL_VALUE_BISHOP = 550;
    public static final short EG_MATERIAL_VALUE_KNIGHT = 520;
    public static final short EG_MATERIAL_VALUE_PAWN = 130;
    
    public static final short [][] PIECE_TO_MATERIAL_LUT;
    static {
        PIECE_TO_MATERIAL_LUT = new short [2][];
        
        PIECE_TO_MATERIAL_LUT[0] = new short [PIECE_LENGTH];
        PIECE_TO_MATERIAL_LUT[0][WHITE_QUEEN] = MATERIAL_VALUE_QUEEN;
        PIECE_TO_MATERIAL_LUT[0][WHITE_ROOK] = MATERIAL_VALUE_ROOK;
        PIECE_TO_MATERIAL_LUT[0][WHITE_BISHOP] = MATERIAL_VALUE_BISHOP;
        PIECE_TO_MATERIAL_LUT[0][WHITE_KNIGHT] = MATERIAL_VALUE_KNIGHT;
        PIECE_TO_MATERIAL_LUT[0][WHITE_KING] = MATERIAL_VALUE_KING;
        PIECE_TO_MATERIAL_LUT[0][WHITE_PAWN] = MATERIAL_VALUE_PAWN;
        
        PIECE_TO_MATERIAL_LUT[0][BLACK_QUEEN] = -MATERIAL_VALUE_QUEEN;
        PIECE_TO_MATERIAL_LUT[0][BLACK_ROOK] = -MATERIAL_VALUE_ROOK;
        PIECE_TO_MATERIAL_LUT[0][BLACK_BISHOP] = -MATERIAL_VALUE_BISHOP;
        PIECE_TO_MATERIAL_LUT[0][BLACK_KNIGHT] = -MATERIAL_VALUE_KNIGHT;
        PIECE_TO_MATERIAL_LUT[0][BLACK_KING] = -MATERIAL_VALUE_KING;
        PIECE_TO_MATERIAL_LUT[0][BLACK_PAWN] = -MATERIAL_VALUE_PAWN;
        
        PIECE_TO_MATERIAL_LUT[1] = new short [PIECE_LENGTH];
        PIECE_TO_MATERIAL_LUT[1][WHITE_QUEEN] = EG_MATERIAL_VALUE_QUEEN;
        PIECE_TO_MATERIAL_LUT[1][WHITE_ROOK] = EG_MATERIAL_VALUE_ROOK;
        PIECE_TO_MATERIAL_LUT[1][WHITE_BISHOP] = EG_MATERIAL_VALUE_BISHOP;
        PIECE_TO_MATERIAL_LUT[1][WHITE_KNIGHT] = EG_MATERIAL_VALUE_KNIGHT;
        PIECE_TO_MATERIAL_LUT[1][WHITE_KING] = EG_MATERIAL_VALUE_KING;
        PIECE_TO_MATERIAL_LUT[1][WHITE_PAWN] = EG_MATERIAL_VALUE_PAWN;
        
        PIECE_TO_MATERIAL_LUT[1][BLACK_QUEEN] = -EG_MATERIAL_VALUE_QUEEN;
        PIECE_TO_MATERIAL_LUT[1][BLACK_ROOK] = -EG_MATERIAL_VALUE_ROOK;
        PIECE_TO_MATERIAL_LUT[1][BLACK_BISHOP] = -EG_MATERIAL_VALUE_BISHOP;
        PIECE_TO_MATERIAL_LUT[1][BLACK_KNIGHT] = -EG_MATERIAL_VALUE_KNIGHT;
        PIECE_TO_MATERIAL_LUT[1][BLACK_KING] = -EG_MATERIAL_VALUE_KING;
        PIECE_TO_MATERIAL_LUT[1][BLACK_PAWN] = -EG_MATERIAL_VALUE_PAWN;
    }
    
    public static final int [] PIECE_PHASE;
    static {
        PIECE_PHASE = new int[PIECE_LENGTH];
        PIECE_PHASE[WHITE_QUEEN] = PIECE_PHASE[BLACK_QUEEN] = 640;
        PIECE_PHASE[WHITE_ROOK] = PIECE_PHASE[BLACK_ROOK] = 320;
        PIECE_PHASE[WHITE_BISHOP] = PIECE_PHASE[WHITE_KNIGHT] = PIECE_PHASE[BLACK_BISHOP] = PIECE_PHASE[BLACK_KNIGHT] = 192;
    }
    
    static final byte[] PAWN_WHITE_WEIGHTINGS;
    static {
        PAWN_WHITE_WEIGHTINGS = new byte[64];
        PAWN_WHITE_WEIGHTINGS[BitBoard.c3] = 0; PAWN_WHITE_WEIGHTINGS[BitBoard.d3] = 5; PAWN_WHITE_WEIGHTINGS[BitBoard.e3] = 5; PAWN_WHITE_WEIGHTINGS[BitBoard.f3] = 0;
        PAWN_WHITE_WEIGHTINGS[BitBoard.c4] = 3; PAWN_WHITE_WEIGHTINGS[BitBoard.d4] = 10; PAWN_WHITE_WEIGHTINGS[BitBoard.e4] = 10; PAWN_WHITE_WEIGHTINGS[BitBoard.f4] = 3;
    }
    
    static final byte[] PAWN_BLACK_WEIGHTINGS;
    static {
        PAWN_BLACK_WEIGHTINGS = new byte[64];
        PAWN_BLACK_WEIGHTINGS[BitBoard.c5] = 3; PAWN_BLACK_WEIGHTINGS[BitBoard.d5] = 10; PAWN_BLACK_WEIGHTINGS[BitBoard.e5] = 10; PAWN_BLACK_WEIGHTINGS[BitBoard.f5] = 3;
        PAWN_BLACK_WEIGHTINGS[BitBoard.c6] = 0; PAWN_BLACK_WEIGHTINGS[BitBoard.d6] = 5; PAWN_BLACK_WEIGHTINGS[BitBoard.e6] = 5; PAWN_BLACK_WEIGHTINGS[BitBoard.f6] = 0;
        for (int i=0;i<64;i++) {
            PAWN_BLACK_WEIGHTINGS[i] = (byte)-PAWN_BLACK_WEIGHTINGS[i];
        }
    }
    
    static final byte[] PAWN_WHITE_ENDGAME_WEIGHTINGS;
    static {
        PAWN_WHITE_ENDGAME_WEIGHTINGS = new byte[64];
        PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.a3] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.b3] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.c3] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.d3] = 5; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.e3] = 5; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.f3] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.g3] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.h3] = 0;
        PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.a4] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.b4] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.c4] = 3; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.d4] = 8; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.e4] = 8;PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.f4] = 3; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.g4] = 0; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.h4] = 0;
        PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.a5] = 2; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.b5] = 3; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.c5] = 8; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.d5] = 12; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.e5] = 12; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.f5] = 8; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.g5] = 3; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.h5] = 2;
        PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.a6] = 4; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.b6] = 8; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.c6] = 12; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.d6] = 16; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.e6] = 16; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.f6] = 12; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.g6] = 8; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.h6] = 4;
        PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.a7] = 5; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.b7] = 10; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.c7] = 15; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.d7] = 20; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.e7] = 20; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.f7] = 15; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.g7] = 10; PAWN_WHITE_ENDGAME_WEIGHTINGS[BitBoard.h7] = 5;
    }
    
    static final byte[] PAWN_BLACK_ENDGAME_WEIGHTINGS;
    static {
        PAWN_BLACK_ENDGAME_WEIGHTINGS = new byte[64];
        PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.a2] = 5; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.b2] = 10; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.c2] = 15; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.d2] = 20;PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.e2] = 20;PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.f2] = 15; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.g2] = 10; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.h2] = 5;
        PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.a3] = 4; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.b3] = 8; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.c3] = 12; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.d3] = 16;PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.e3] = 16;PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.f3] = 12; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.g3] = 8; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.h3] = 4;
        PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.a4] = 2; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.b4] = 3; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.c4] = 8; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.d4] = 12;PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.e4] = 12;PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.f4] = 8;PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.g4] = 3; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.h4] = 2;
        PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.a5] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.b5] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.c5] = 3; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.d5] = 8;PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.e5] = 8;PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.f5] = 3;PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.g5] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.h5] = 0;
        PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.a6] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.b6] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.c6] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.d6] = 5;PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.e6] = 5;PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.f6] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.g6] = 0; PAWN_BLACK_ENDGAME_WEIGHTINGS[BitBoard.h6] = 0;
        for (int i=0;i<64;i++) {
            PAWN_BLACK_ENDGAME_WEIGHTINGS[i] = (byte)-PAWN_BLACK_ENDGAME_WEIGHTINGS[i];
        }
    }  
    
    static final byte[] ROOK_WHITE_WEIGHTINGS;
    static {
        ROOK_WHITE_WEIGHTINGS = new byte[64];
        ROOK_WHITE_WEIGHTINGS[BitBoard.a1] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.b1] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.c1] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.d1] = 5; ROOK_WHITE_WEIGHTINGS[BitBoard.e1] = 5; ROOK_WHITE_WEIGHTINGS[BitBoard.f1] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.g1] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.h1] = 0;
        ROOK_WHITE_WEIGHTINGS[BitBoard.a2] = -10; ROOK_WHITE_WEIGHTINGS[BitBoard.b2] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.c2] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.d2] = 5; ROOK_WHITE_WEIGHTINGS[BitBoard.e2] = 5; ROOK_WHITE_WEIGHTINGS[BitBoard.f2] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.g2] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.h2] = -10;
        ROOK_WHITE_WEIGHTINGS[BitBoard.a3] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.b3] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.c3] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.d3] = 5; ROOK_WHITE_WEIGHTINGS[BitBoard.e3] = 5; ROOK_WHITE_WEIGHTINGS[BitBoard.f3] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.g3] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.h3] = 0;
        ROOK_WHITE_WEIGHTINGS[BitBoard.a4] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.b4] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.c4] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.d4] = 5; ROOK_WHITE_WEIGHTINGS[BitBoard.e4] = 5; ROOK_WHITE_WEIGHTINGS[BitBoard.f4] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.g4] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.h4] = 0;
        ROOK_WHITE_WEIGHTINGS[BitBoard.a5] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.b5] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.c5] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.d5] = 5; ROOK_WHITE_WEIGHTINGS[BitBoard.e5] = 5; ROOK_WHITE_WEIGHTINGS[BitBoard.f5] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.g5] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.h5] = 0;
        ROOK_WHITE_WEIGHTINGS[BitBoard.a6] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.b6] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.c6] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.d6] = 5; ROOK_WHITE_WEIGHTINGS[BitBoard.e6] = 5; ROOK_WHITE_WEIGHTINGS[BitBoard.f6] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.g6] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.h6] = 0;
        ROOK_WHITE_WEIGHTINGS[BitBoard.a7] = 20; ROOK_WHITE_WEIGHTINGS[BitBoard.b7] = 20; ROOK_WHITE_WEIGHTINGS[BitBoard.c7] = 20; ROOK_WHITE_WEIGHTINGS[BitBoard.d7] = 20; ROOK_WHITE_WEIGHTINGS[BitBoard.e7] = 20; ROOK_WHITE_WEIGHTINGS[BitBoard.f7] = 20; ROOK_WHITE_WEIGHTINGS[BitBoard.g7] = 20; ROOK_WHITE_WEIGHTINGS[BitBoard.h7] = 20;
        ROOK_WHITE_WEIGHTINGS[BitBoard.a8] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.b8] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.c8] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.d8] = 5; ROOK_WHITE_WEIGHTINGS[BitBoard.e8] = 5; ROOK_WHITE_WEIGHTINGS[BitBoard.f8] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.g8] = 0; ROOK_WHITE_WEIGHTINGS[BitBoard.h8] = 0;
    }
    
    static final byte[] ROOK_BLACK_WEIGHTINGS;
    static {
        ROOK_BLACK_WEIGHTINGS = new byte[64];
        ROOK_BLACK_WEIGHTINGS[BitBoard.a1] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.b1] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.c1] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.d1] = 5; ROOK_BLACK_WEIGHTINGS[BitBoard.e1] = 5; ROOK_BLACK_WEIGHTINGS[BitBoard.f1] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.g1] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.h1] = 0;
        ROOK_BLACK_WEIGHTINGS[BitBoard.a2] = 20; ROOK_BLACK_WEIGHTINGS[BitBoard.b2] = 20; ROOK_BLACK_WEIGHTINGS[BitBoard.c2] = 20; ROOK_BLACK_WEIGHTINGS[BitBoard.d2] = 20; ROOK_BLACK_WEIGHTINGS[BitBoard.e2] = 20; ROOK_BLACK_WEIGHTINGS[BitBoard.f2] = 20; ROOK_BLACK_WEIGHTINGS[BitBoard.g2] = 20; ROOK_BLACK_WEIGHTINGS[BitBoard.h2] = 20;
        ROOK_BLACK_WEIGHTINGS[BitBoard.a3] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.b3] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.c3] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.d3] = 5; ROOK_BLACK_WEIGHTINGS[BitBoard.e3] = 5; ROOK_BLACK_WEIGHTINGS[BitBoard.f3] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.g3] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.h3] = 0;
        ROOK_BLACK_WEIGHTINGS[BitBoard.a4] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.b4] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.c4] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.d4] = 5; ROOK_BLACK_WEIGHTINGS[BitBoard.e4] = 5; ROOK_BLACK_WEIGHTINGS[BitBoard.f4] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.g4] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.h4] = 0;
        ROOK_BLACK_WEIGHTINGS[BitBoard.a5] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.b5] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.c5] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.d5] = 5; ROOK_BLACK_WEIGHTINGS[BitBoard.e5] = 5; ROOK_BLACK_WEIGHTINGS[BitBoard.f5] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.g5] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.h5] = 0;
        ROOK_BLACK_WEIGHTINGS[BitBoard.a6] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.b6] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.c6] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.d6] = 5; ROOK_BLACK_WEIGHTINGS[BitBoard.e6] = 5; ROOK_BLACK_WEIGHTINGS[BitBoard.f6] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.g6] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.h6] = 0;
        ROOK_BLACK_WEIGHTINGS[BitBoard.a7] = -10; ROOK_BLACK_WEIGHTINGS[BitBoard.b7] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.c7] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.d7] = 5; ROOK_BLACK_WEIGHTINGS[BitBoard.e7] = 5; ROOK_BLACK_WEIGHTINGS[BitBoard.f7] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.g7] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.h7] = -10;
        ROOK_BLACK_WEIGHTINGS[BitBoard.a8] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.b8] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.c8] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.d8] = 5; ROOK_BLACK_WEIGHTINGS[BitBoard.e8] = 5; ROOK_BLACK_WEIGHTINGS[BitBoard.f8] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.g8] = 0; ROOK_BLACK_WEIGHTINGS[BitBoard.h8] = 0;
        for (int i=0;i<64;i++) {
            ROOK_BLACK_WEIGHTINGS[i] = (byte)-ROOK_BLACK_WEIGHTINGS[i];
        }
    }
    
    static final byte[] KNIGHT_WHITE_WEIGHTINGS;
    static {
        KNIGHT_WHITE_WEIGHTINGS = new byte[64];
        KNIGHT_WHITE_WEIGHTINGS[BitBoard.a1] = -20;KNIGHT_WHITE_WEIGHTINGS[BitBoard.b1] = -10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.c1] = -10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.d1] = -10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.e1] = -10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.f1] = -10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.g1] = -10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.h1] = -20;
        KNIGHT_WHITE_WEIGHTINGS[BitBoard.a2] = -10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.b2] = 0;KNIGHT_WHITE_WEIGHTINGS[BitBoard.c2] = 0;KNIGHT_WHITE_WEIGHTINGS[BitBoard.d2] = 0;KNIGHT_WHITE_WEIGHTINGS[BitBoard.e2] = 0;KNIGHT_WHITE_WEIGHTINGS[BitBoard.f2] = 0;KNIGHT_WHITE_WEIGHTINGS[BitBoard.g2] = 0;KNIGHT_WHITE_WEIGHTINGS[BitBoard.h2] = -10;
        KNIGHT_WHITE_WEIGHTINGS[BitBoard.a3] = -10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.b3] = 0;KNIGHT_WHITE_WEIGHTINGS[BitBoard.c3] = 10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.d3] = 10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.e3] = 10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.f3] = 10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.g3] = 0;KNIGHT_WHITE_WEIGHTINGS[BitBoard.h3] = -10;
        KNIGHT_WHITE_WEIGHTINGS[BitBoard.a4] = -10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.b4] = 0;KNIGHT_WHITE_WEIGHTINGS[BitBoard.c4] = 10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.d4] = 20;KNIGHT_WHITE_WEIGHTINGS[BitBoard.e4] = 20;KNIGHT_WHITE_WEIGHTINGS[BitBoard.f4] = 10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.g4] = 0;KNIGHT_WHITE_WEIGHTINGS[BitBoard.h4] = -10;
        KNIGHT_WHITE_WEIGHTINGS[BitBoard.a5] = -10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.b5] = 0;KNIGHT_WHITE_WEIGHTINGS[BitBoard.c5] = 10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.d5] = 20;KNIGHT_WHITE_WEIGHTINGS[BitBoard.e5] = 20;KNIGHT_WHITE_WEIGHTINGS[BitBoard.f5] = 10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.g5] = 0;KNIGHT_WHITE_WEIGHTINGS[BitBoard.h5] = -10;
        KNIGHT_WHITE_WEIGHTINGS[BitBoard.a6] = -10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.b6] = 0;KNIGHT_WHITE_WEIGHTINGS[BitBoard.c6] = 10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.d6] = 10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.e6] = 10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.f6] = 10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.g6] = 0;KNIGHT_WHITE_WEIGHTINGS[BitBoard.h6] = -10;
        KNIGHT_WHITE_WEIGHTINGS[BitBoard.a7] = -10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.b7] = 0;KNIGHT_WHITE_WEIGHTINGS[BitBoard.c7] = 0;KNIGHT_WHITE_WEIGHTINGS[BitBoard.d7] = 0;KNIGHT_WHITE_WEIGHTINGS[BitBoard.e7] = 0;KNIGHT_WHITE_WEIGHTINGS[BitBoard.f7] = 0;KNIGHT_WHITE_WEIGHTINGS[BitBoard.g7] = 0;KNIGHT_WHITE_WEIGHTINGS[BitBoard.h7] = -10;
        KNIGHT_WHITE_WEIGHTINGS[BitBoard.a8] = -20;KNIGHT_WHITE_WEIGHTINGS[BitBoard.b8] = -10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.c8] = -10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.d8] = -10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.e8] = -10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.f8] = -10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.g8] = -10;KNIGHT_WHITE_WEIGHTINGS[BitBoard.h8] = -20;
    }
    
    static final byte[] KNIGHT_BLACK_WEIGHTINGS;
    static {
        KNIGHT_BLACK_WEIGHTINGS = new byte[64];
        KNIGHT_BLACK_WEIGHTINGS[BitBoard.a1] = -20;KNIGHT_BLACK_WEIGHTINGS[BitBoard.b1] = -10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.c1] = -10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.d1] = -10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.e1] = -10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.f1] = -10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.g1] = -10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.h1] = -20;
        KNIGHT_BLACK_WEIGHTINGS[BitBoard.a2] = -10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.b2] = 0;KNIGHT_BLACK_WEIGHTINGS[BitBoard.c2] = 0;KNIGHT_BLACK_WEIGHTINGS[BitBoard.d2] = 0;KNIGHT_BLACK_WEIGHTINGS[BitBoard.e2] = 0;KNIGHT_BLACK_WEIGHTINGS[BitBoard.f2] = 0;KNIGHT_BLACK_WEIGHTINGS[BitBoard.g2] = 0;KNIGHT_BLACK_WEIGHTINGS[BitBoard.h2] = -10;
        KNIGHT_BLACK_WEIGHTINGS[BitBoard.a3] = -10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.b3] = 0;KNIGHT_BLACK_WEIGHTINGS[BitBoard.c3] = 10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.d3] = 10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.e3] = 10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.f3] = 10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.g3] = 0;KNIGHT_BLACK_WEIGHTINGS[BitBoard.h3] = -10;
        KNIGHT_BLACK_WEIGHTINGS[BitBoard.a4] = -10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.b4] = 0;KNIGHT_BLACK_WEIGHTINGS[BitBoard.c4] = 10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.d4] = 20;KNIGHT_BLACK_WEIGHTINGS[BitBoard.e4] = 20;KNIGHT_BLACK_WEIGHTINGS[BitBoard.f4] = 10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.g4] = 0;KNIGHT_BLACK_WEIGHTINGS[BitBoard.h4] = -10;
        KNIGHT_BLACK_WEIGHTINGS[BitBoard.a5] = -10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.b5] = 0;KNIGHT_BLACK_WEIGHTINGS[BitBoard.c5] = 10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.d5] = 20;KNIGHT_BLACK_WEIGHTINGS[BitBoard.e5] = 20;KNIGHT_BLACK_WEIGHTINGS[BitBoard.f5] = 10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.g5] = 0;KNIGHT_BLACK_WEIGHTINGS[BitBoard.h5] = -10;
        KNIGHT_BLACK_WEIGHTINGS[BitBoard.a6] = -10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.b6] = 0;KNIGHT_BLACK_WEIGHTINGS[BitBoard.c6] = 10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.d6] = 10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.e6] = 10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.f6] = 10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.g6] = 0;KNIGHT_BLACK_WEIGHTINGS[BitBoard.h6] = -10;
        KNIGHT_BLACK_WEIGHTINGS[BitBoard.a7] = -10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.b7] = 0;KNIGHT_BLACK_WEIGHTINGS[BitBoard.c7] = 0;KNIGHT_BLACK_WEIGHTINGS[BitBoard.d7] = 0;KNIGHT_BLACK_WEIGHTINGS[BitBoard.e7] = 0;KNIGHT_BLACK_WEIGHTINGS[BitBoard.f7] = 0;KNIGHT_BLACK_WEIGHTINGS[BitBoard.g7] = 0;KNIGHT_BLACK_WEIGHTINGS[BitBoard.h7] = -10;
        KNIGHT_BLACK_WEIGHTINGS[BitBoard.a8] = -20;KNIGHT_BLACK_WEIGHTINGS[BitBoard.b8] = -10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.c8] = -10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.d8] = -10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.e8] = -10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.f8] = -10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.g8] = -10;KNIGHT_BLACK_WEIGHTINGS[BitBoard.h8] = -20;
        for (int i=0;i<64;i++) {
            KNIGHT_BLACK_WEIGHTINGS[i] = (byte)-KNIGHT_BLACK_WEIGHTINGS[i];
        }
    }
    
    static final byte[] KING_WHITE_ENDGAME_WEIGHTINGS;
    static {
        KING_WHITE_ENDGAME_WEIGHTINGS = new byte[64];
        KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.a1] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.b1] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.c1] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.d1] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.e1] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.f1] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.g1] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.h1] = -30;
        KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.a2] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.b2] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.c2] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.d2] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.e2] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.f2] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.g2] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.h2] = -30;
        KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.a3] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.b3] = -10;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.c3] = 0;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.d3] = 10;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.e3] = 10;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.f3] = 0;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.g3] = -10;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.h3] = -30;
        KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.a4] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.b4] = -10;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.c4] = 10;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.d4] = 20;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.e4] = 20;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.f4] = 10;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.g4] = -10;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.h4] = -20;
        KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.a5] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.b5] = -10;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.c5] = 10;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.d5] = 20;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.e5] = 20;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.f5] = 10;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.g5] = -10;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.h5] = -20;
        KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.a6] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.b6] = -10;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.c6] = 0;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.d6] = 10;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.e6] = 10;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.f6] = 0;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.g6] = -10;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.h6] = -30;
        KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.a7] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.b7] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.c7] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.d7] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.e7] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.f7] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.g7] = -20;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.h7] = -30;
        KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.a8] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.b8] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.c8] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.d8] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.e8] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.f8] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.g8] = -30;KING_WHITE_ENDGAME_WEIGHTINGS[BitBoard.h8] = -30;
    }
    
    static final byte[] KING_WHITE_MIDGAME_WEIGHTINGS;
    static {
        KING_WHITE_MIDGAME_WEIGHTINGS = new byte[64];
        KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.a1] = 5;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.b1] = 25;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.c1] = 50;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.d1] = 0;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.e1] = 0;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.f1] = 5;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.g1] = 50;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.h1] = 5;
        KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.a2] = 0;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.b2] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.c2] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.d2] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.e2] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.f2] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.g2] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.h2] = -10;
        KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.a3] = -20;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.b3] = -20;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.c3] = -30;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.d3] = -30;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.e3] = -30;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.f3] = -30;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.g3] = -20;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.h3] = -20;
        KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.a4] = -30;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.b4] = -40;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.c4] = -50;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.d4] = -50;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.e4] = -50;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.f4] = -40;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.g4] = -40;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.h4] = -30;
        KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.a5] = -30;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.b5] = -40;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.c5] = -50;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.d5] = -50;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.e5] = -50;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.f5] = -40;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.g5] = -40;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.h5] = -30;
        KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.a6] = -20;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.b6] = -20;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.c6] = -30;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.d6] = -30;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.e6] = -30;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.f6] = -30;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.g6] = -20;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.h6] = -20;
        KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.a7] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.b7] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.c7] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.d7] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.e7] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.f7] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.g7] = -10;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.h7] = -10;
        KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.a8] = 5;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.b8] = 25;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.c8] = 50;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.d8] = 0;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.e8] = 0;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.f8] = 5;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.g8] = 50;KING_WHITE_MIDGAME_WEIGHTINGS[BitBoard.h8] = 5;
    }
    
    static final byte[] KING_BLACK_ENDGAME_WEIGHTINGS;
    static {
        KING_BLACK_ENDGAME_WEIGHTINGS = new byte[64];
        KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.a1] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.b1] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.c1] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.d1] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.e1] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.f1] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.g1] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.h1] = -30;
        KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.a2] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.b2] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.c2] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.d2] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.e2] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.f2] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.g2] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.h2] = -30;
        KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.a3] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.b3] = -10;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.c3] = 0;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.d3] = 10;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.e3] = 10;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.f3] = 0;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.g3] = -10;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.h3] = -30;
        KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.a4] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.b4] = -10;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.c4] = 10;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.d4] = 20;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.e4] = 20;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.f4] = 10;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.g4] = -10;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.h4] = -20;
        KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.a5] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.b5] = -10;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.c5] = 10;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.d5] = 20;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.e5] = 20;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.f5] = 10;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.g5] = -10;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.h5] = -20;
        KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.a6] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.b6] = -10;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.c6] = 0;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.d6] = 10;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.e6] = 10;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.f6] = 0;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.g6] = -10;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.h6] = -30;
        KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.a7] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.b7] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.c7] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.d7] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.e7] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.f7] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.g7] = -20;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.h7] = -30;
        KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.a8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.b8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.c8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.d8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.e8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.f8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.g8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.h8] = -30;
        for (int i=0;i<64;i++) {
            KING_BLACK_ENDGAME_WEIGHTINGS[i] = (byte)-KING_BLACK_ENDGAME_WEIGHTINGS[i];
        }
    }
    
    static final byte[] KING_BLACK_MIDGAME_WEIGHTINGS;
    static {
        KING_BLACK_MIDGAME_WEIGHTINGS = new byte[64];
        KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.a1] = 5;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.b1] = 25;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.c1] = 50;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.d1] = 0;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.e1] = 0;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.f1] = 5;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.g1] = 50;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.h1] = 5;
        KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.a2] = 0;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.b2] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.c2] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.d2] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.e2] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.f2] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.g2] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.h2] = -10;
        KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.a3] = -20;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.b3] = -20;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.c3] = -30;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.d3] = -30;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.e3] = -30;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.f3] = -30;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.g3] = -20;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.h3] = -20;
        KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.a4] = -30;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.b4] = -40;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.c4] = -50;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.d4] = -50;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.e4] = -50;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.f4] = -40;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.g4] = -40;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.h4] = -30;
        KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.a5] = -30;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.b5] = -40;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.c5] = -50;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.d5] = -50;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.e5] = -50;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.f5] = -40;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.g5] = -40;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.h5] = -30;
        KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.a6] = -20;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.b6] = -20;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.c6] = -30;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.d6] = -30;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.e6] = -30;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.f6] = -30;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.g6] = -20;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.h6] = -20;
        KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.a7] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.b7] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.c7] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.d7] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.e7] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.f7] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.g7] = -10;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.h7] = -10;
        KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.a8] = 5;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.b8] = 25;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.c8] = 50;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.d8] = 0;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.e8] = 0;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.f8] = 5;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.g8] = 50;KING_BLACK_MIDGAME_WEIGHTINGS[BitBoard.h8] = 5;
        KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.a8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.b8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.c8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.d8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.e8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.f8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.g8] = -30;KING_BLACK_ENDGAME_WEIGHTINGS[BitBoard.h8] = -30;
        for (int i=0;i<64;i++) {
            KING_BLACK_MIDGAME_WEIGHTINGS[i] = (byte)-KING_BLACK_MIDGAME_WEIGHTINGS[i];
        }
    }
    
    static final byte[] ZERO_WEIGHTING = new byte[64];
    
    static final byte [][] PIECE_SQUARE_TABLES;
    static {
        PIECE_SQUARE_TABLES = new byte[15][64];
        
        PIECE_SQUARE_TABLES[Piece.WHITE_PAWN] = PAWN_WHITE_WEIGHTINGS;
        PIECE_SQUARE_TABLES[Piece.WHITE_KING] = KING_WHITE_MIDGAME_WEIGHTINGS;
        PIECE_SQUARE_TABLES[Piece.WHITE_QUEEN] = ZERO_WEIGHTING;
        PIECE_SQUARE_TABLES[Piece.WHITE_ROOK] = ROOK_WHITE_WEIGHTINGS;
        PIECE_SQUARE_TABLES[Piece.WHITE_BISHOP] = ZERO_WEIGHTING;
        PIECE_SQUARE_TABLES[Piece.WHITE_KNIGHT] = KNIGHT_WHITE_WEIGHTINGS;
        
        PIECE_SQUARE_TABLES[Piece.BLACK_PAWN] = PAWN_BLACK_WEIGHTINGS;
        PIECE_SQUARE_TABLES[Piece.BLACK_KING] = KING_BLACK_MIDGAME_WEIGHTINGS;
        PIECE_SQUARE_TABLES[Piece.BLACK_QUEEN] = ZERO_WEIGHTING;
        PIECE_SQUARE_TABLES[Piece.BLACK_ROOK] = ROOK_BLACK_WEIGHTINGS;
        PIECE_SQUARE_TABLES[Piece.BLACK_BISHOP] = ZERO_WEIGHTING;
        PIECE_SQUARE_TABLES[Piece.BLACK_KNIGHT] = KNIGHT_BLACK_WEIGHTINGS;
    }
    
    static final byte [][] ENDGAME_PIECE_SQUARE_TABLES;
    static {
        ENDGAME_PIECE_SQUARE_TABLES = new byte[15][128];
        
        ENDGAME_PIECE_SQUARE_TABLES[Piece.WHITE_PAWN] = PAWN_WHITE_ENDGAME_WEIGHTINGS;
        ENDGAME_PIECE_SQUARE_TABLES[Piece.WHITE_KING] = KING_WHITE_ENDGAME_WEIGHTINGS;
        ENDGAME_PIECE_SQUARE_TABLES[Piece.WHITE_QUEEN] = ZERO_WEIGHTING;
        ENDGAME_PIECE_SQUARE_TABLES[Piece.WHITE_ROOK] = ZERO_WEIGHTING;
        ENDGAME_PIECE_SQUARE_TABLES[Piece.WHITE_BISHOP] = ZERO_WEIGHTING;
        ENDGAME_PIECE_SQUARE_TABLES[Piece.WHITE_KNIGHT] = KNIGHT_WHITE_WEIGHTINGS;
        
        ENDGAME_PIECE_SQUARE_TABLES[Piece.BLACK_PAWN] = PAWN_BLACK_ENDGAME_WEIGHTINGS;
        ENDGAME_PIECE_SQUARE_TABLES[Piece.BLACK_KING] = KING_BLACK_ENDGAME_WEIGHTINGS;
        ENDGAME_PIECE_SQUARE_TABLES[Piece.BLACK_QUEEN] = ZERO_WEIGHTING;
        ENDGAME_PIECE_SQUARE_TABLES[Piece.BLACK_ROOK] = ZERO_WEIGHTING;
        ENDGAME_PIECE_SQUARE_TABLES[Piece.BLACK_BISHOP] = ZERO_WEIGHTING;
        ENDGAME_PIECE_SQUARE_TABLES[Piece.BLACK_KNIGHT] = KNIGHT_BLACK_WEIGHTINGS;
    }
    
    public static int convertChessmanToPiece(int chessman, boolean isWhite) {
        int eubosPiece = Piece.NONE;
        if (chessman==IntChessman.KNIGHT)
            eubosPiece = isWhite ? Piece.WHITE_KNIGHT : Piece.BLACK_KNIGHT;
        else if (chessman==IntChessman.BISHOP)
            eubosPiece = isWhite ? Piece.WHITE_BISHOP : Piece.BLACK_BISHOP;
        else if (chessman==IntChessman.ROOK)
            eubosPiece = isWhite? Piece.WHITE_ROOK : Piece.BLACK_ROOK;
        else if (chessman==IntChessman.QUEEN)
            eubosPiece = isWhite ? Piece.WHITE_QUEEN : Piece.BLACK_QUEEN;
        return eubosPiece;
    }
    
    public static int convertPieceToChessman(int piece) {
        int chessman = IntChessman.NOCHESSMAN;
        if (Piece.isKnight(piece))
            chessman = IntChessman.KNIGHT;
        else if (Piece.isBishop(piece))
            chessman = IntChessman.BISHOP;
        else if (Piece.isRook(piece))
            chessman = IntChessman.ROOK;
        else if (Piece.isQueen(piece))
            chessman = IntChessman.QUEEN;
        else if (Piece.isKing(piece))
            chessman = IntChessman.KING;
        else if (Piece.isPawn(piece))
            chessman = IntChessman.PAWN;        
        return chessman;
    }
    
    public static char toFenChar(int piece) {
        char chessman = 0;
        if (piece==Piece.WHITE_PAWN)
            chessman = 'P';
        else if (piece==Piece.WHITE_KNIGHT)
            chessman = 'N';
        else if (piece==Piece.WHITE_BISHOP)
            chessman = 'B';
        else if (piece==Piece.WHITE_ROOK)
            chessman = 'R';
        else if (piece==Piece.WHITE_QUEEN)
            chessman = 'Q';
        else if (piece==Piece.WHITE_KING)
            chessman = 'K';
        else if (piece==Piece.BLACK_PAWN)
            chessman = 'p';
        else if (piece==Piece.BLACK_KNIGHT)
            chessman = 'n';
        else if (piece==Piece.BLACK_BISHOP)
            chessman = 'b';
        else if (piece==Piece.BLACK_ROOK)
            chessman = 'r';
        else if (piece==Piece.BLACK_QUEEN)
            chessman = 'q';
        else if (piece==Piece.BLACK_KING)
            chessman = 'k';
        return chessman;
    }
    
    public static String reportStaticDataSizes() {
        StringBuilder s = new StringBuilder();
        s.append(String.format("KnightMove_Lut_Size %d bytes\n", KnightMove_Lut_Size*4));
        s.append(String.format("KingMove_Lut_Size %d bytes\n", KingMove_Lut_Size*4));
        s.append(String.format("QueenMove_Lut_Size %d bytes\n", QueenMove_Lut_Size*4));
        s.append(String.format("RookMove_Lut_Size %d bytes\n", RookMove_Lut_Size*4));
        s.append(String.format("BishopMove_Lut_Size %d bytes\n", BishopMove_Lut_Size*4));
        return s.toString();
    }
    
    public static int getStaticDataSize() {
        return (KnightMove_Lut_Size + KingMove_Lut_Size + QueenMove_Lut_Size + RookMove_Lut_Size + BishopMove_Lut_Size) * 4;
    }
    
    static int KnightMove_Lut_Size = 0;
    static final int[][] WhiteKnightMove_Lut = new int[64][];
    static {
        int bitOffset = 0;
        for (int square : Position.values) {
            WhiteKnightMove_Lut[bitOffset++] = createKnightMovesFromOriginPosition(square, true);
        }
    }
    static final int[][] BlackKnightMove_Lut = new int[64][];
    static {
        int bitOffset = 0;
        for (int square : Position.values) {
            BlackKnightMove_Lut[bitOffset++] = createKnightMovesFromOriginPosition(square, false);
        }
    }
    static int [] createKnightMovesFromOriginPosition(int originPosition, boolean isWhite) {
        int originPiece = isWhite ? Piece.WHITE_KNIGHT : Piece.BLACK_KNIGHT;
        int count = 0;
        int [] moves = new int[8];
        // Create reference moves (with target none)
        for (Direction dir: Direction.values()) {
            int targetPosition = Direction.getIndirectMoveSq(dir, originPosition);
            if (targetPosition != Position.NOPOSITION) {
                moves[count] = Move.valueOf(originPosition, originPiece, targetPosition, Piece.NONE);
                count++;
            }
        }
        // Copy to correctly sized array
        int [] ref_moves = Arrays.copyOf(moves, count);
        KnightMove_Lut_Size += ref_moves.length;
        return ref_moves;
    }
    
    static int KingMove_Lut_Size = 0;
    static final int[][] WhiteKingMove_Lut = new int[64][];
    static {
        int bitOffset = 0;
        for (int square : Position.values) {
            WhiteKingMove_Lut[bitOffset++] = createKingMovesFromOriginPosition(square, true);
        }
    }
    static final int[][] BlackKingMove_Lut = new int[64][];
    static {
        int bitOffset = 0;
        for (int square : Position.values) {
            BlackKingMove_Lut[bitOffset++] = createKingMovesFromOriginPosition(square, false);
        }
    }
    static int [] createKingMovesFromOriginPosition(int originPosition, boolean isWhite) {
        Direction [] allDirect = { Direction.up, Direction.upRight, Direction.right, Direction.downRight, Direction.down, Direction.downLeft, Direction.left, Direction.upLeft };
        int originPiece = isWhite ? Piece.WHITE_KING : Piece.BLACK_KING;
        int count = 0;
        int [] moves = new int[8];
        // Create reference moves (with target none)
        for (Direction dir: allDirect) {
            int targetPosition = Direction.getDirectMoveSq(dir, originPosition);
            if (targetPosition != Position.NOPOSITION) {
                moves[count] = Move.valueOf(originPosition, originPiece, targetPosition, Piece.NONE);
                count++;
            }
        }
        // Copy to correctly sized array
        int [] ref_moves = Arrays.copyOf(moves, count);
        KingMove_Lut_Size += ref_moves.length;
        return ref_moves;
    }
    
    static final int[][] BlackPawnPromotionMove_Lut = new int[64][];
    static {
        int bitOffset = 0;
        for (int square : Position.values) {
            if (Position.getRank(square) == IntRank.R2) {
                BlackPawnPromotionMove_Lut[bitOffset] = createBlackPawnPromotionMovesFromOriginPosition(square);
            }
            bitOffset++;
        }
    }
    static int [] createBlackPawnPromotionMovesFromOriginPosition(int originPosition) {
        int originPiece = Piece.BLACK_PAWN;
        int [] moves = new int[4];
        // Create reference moves (with target none)
        int targetPosition = Direction.getDirectMoveSq(Direction.down, originPosition);
        moves[0] = Move.valueOf(Move.TYPE_PROMOTION_MASK, originPosition, originPiece, targetPosition, Piece.NONE, Piece.QUEEN );
        moves[1] = Move.valueOf(Move.TYPE_PROMOTION_MASK, originPosition, originPiece, targetPosition, Piece.NONE, Piece.ROOK );
        moves[2] = Move.valueOf(Move.TYPE_PROMOTION_MASK, originPosition, originPiece, targetPosition, Piece.NONE, Piece.BISHOP );
        moves[3] = Move.valueOf(Move.TYPE_PROMOTION_MASK, originPosition, originPiece, targetPosition, Piece.NONE, Piece.KNIGHT );
        return moves;
    }
    
    static final int[][] WhitePawnPromotionMove_Lut = new int[64][];
    static {
        int bitOffset = 0;
        for (int square : Position.values) {
            if (Position.getRank(square) == IntRank.R7) {
                WhitePawnPromotionMove_Lut[bitOffset] = createWhitePawnPromotionMovesFromOriginPosition(square);
            }
            bitOffset++;
        }
    }
    static int [] createWhitePawnPromotionMovesFromOriginPosition(int originPosition) {
        int originPiece = Piece.WHITE_PAWN;
        int [] moves = new int[4];
        // Create reference moves (with target none)
        int targetPosition = Direction.getDirectMoveSq(Direction.up, originPosition);
        moves[0] = Move.valueOf(Move.TYPE_PROMOTION_MASK, originPosition, originPiece, targetPosition, Piece.NONE, Piece.QUEEN );
        moves[1] = Move.valueOf(Move.TYPE_PROMOTION_MASK, originPosition, originPiece, targetPosition, Piece.NONE, Piece.ROOK );
        moves[2] = Move.valueOf(Move.TYPE_PROMOTION_MASK, originPosition, originPiece, targetPosition, Piece.NONE, Piece.BISHOP );
        moves[3] = Move.valueOf(Move.TYPE_PROMOTION_MASK, originPosition, originPiece, targetPosition, Piece.NONE, Piece.KNIGHT );
        return moves;
    }
    
    static int RookMove_Lut_Size = 0;
    static final int[][][] WhiteRookMove_Lut = new int[64][][]; // Position by direction by moves in that direction
    static {
        int bitOffset = 0;
        for (int square : Position.values) {
            WhiteRookMove_Lut[bitOffset++] = createRookMovesFromOriginPosition(square, true);
        }
    }
    static final int[][][] BlackRookMove_Lut = new int[64][][];
    static {
        int bitOffset = 0;
        for (int square : Position.values) {
            BlackRookMove_Lut[bitOffset++] = createRookMovesFromOriginPosition(square, false);
        }
    }
    static int [][] createRookMovesFromOriginPosition(int originPosition, boolean isWhite) {
        Direction [] rookDirect = SquareAttackEvaluator.rankFile;
        int originPiece = isWhite ? Piece.WHITE_ROOK: Piece.BLACK_ROOK;
        int [][] return_value = new int [4][];
        int direction_index = 0;
        // Create reference moves (with target none)
        for (Direction dir : rookDirect) {
            int count = 0;
            int [] moves = new int[7];
            // Walk down direction adding all squares to the edge of the board
            int targetPosition = Direction.getDirectMoveSq(dir, originPosition);
            while (targetPosition != Position.NOPOSITION) {
                if (targetPosition != Position.NOPOSITION) {
                    moves[count] = Move.valueOf(originPosition, originPiece, targetPosition, Piece.NONE);
                    count++;
                }
                targetPosition = Direction.getDirectMoveSq(dir, targetPosition);
            }
            // Copy to correctly sized array
            int [] ref_moves = Arrays.copyOf(moves, count);
            return_value[direction_index++] = ref_moves;
            RookMove_Lut_Size += ref_moves.length;
        }
        return return_value;
    }
    
    static int BishopMove_Lut_Size = 0;
    static final int[][][] WhiteBishopMove_Lut = new int[64][][]; // Position by direction by moves in that direction
    static {
        int bitOffset = 0;
        for (int square : Position.values) {
            WhiteBishopMove_Lut[bitOffset++] = createBishopMovesFromOriginPosition(square, true);
        }
    }
    static final int[][][] BlackBishopMove_Lut = new int[64][][];
    static {
        int bitOffset = 0;
        for (int square : Position.values) {
            BlackBishopMove_Lut[bitOffset++] = createBishopMovesFromOriginPosition(square, false);
        }
    }
    static int [][] createBishopMovesFromOriginPosition(int originPosition, boolean isWhite) {
        Direction [] bishopDirect = SquareAttackEvaluator.diagonals;
        int originPiece = isWhite ? Piece.WHITE_BISHOP: Piece.BLACK_BISHOP;
        int [][] return_value = new int [4][];
        int direction_index = 0;
        // Create reference moves (with target none)
        for (Direction dir : bishopDirect) {
            int count = 0;
            int [] moves = new int[7];
            // Walk down direction adding all squares to the edge of the board
            int targetPosition = Direction.getDirectMoveSq(dir, originPosition);
            while (targetPosition != Position.NOPOSITION) {
                if (targetPosition != Position.NOPOSITION) {
                    moves[count] = Move.valueOf(originPosition, originPiece, targetPosition, Piece.NONE);
                    count++;
                }
                targetPosition = Direction.getDirectMoveSq(dir, targetPosition);
            }
            // Copy to correctly sized array
            int [] ref_moves = Arrays.copyOf(moves, count);
            return_value[direction_index++] = ref_moves;
            BishopMove_Lut_Size += ref_moves.length;
        }
        return return_value;
    }
    
    static int QueenMove_Lut_Size = 0;
    static final int[][][] WhiteQueenMove_Lut = new int[64][][]; // Position by direction by moves in that direction
    static {
        int bitOffset = 0;
        for (int square : Position.values) {
            WhiteQueenMove_Lut[bitOffset++] = createQueenMovesFromOriginPosition(square, true);
        }
    }
    static final int[][][] BlackQueenMove_Lut = new int[64][][];
    static {
        int bitOffset = 0;
        for (int square : Position.values) {
            BlackQueenMove_Lut[bitOffset++] = createQueenMovesFromOriginPosition(square, false);
        }
    }
    static int [][] createQueenMovesFromOriginPosition(int originPosition, boolean isWhite) {
        Direction [] queenDirect = SquareAttackEvaluator.allDirect;
        int originPiece = isWhite ? Piece.WHITE_QUEEN: Piece.BLACK_QUEEN;
        int [][] return_value = new int [8][];
        int direction_index = 0;
        // Create reference moves (with target none)
        for (Direction dir : queenDirect) {
            int count = 0;
            int [] moves = new int[7];
            // Walk down direction adding all squares to the edge of the board
            int targetPosition = Direction.getDirectMoveSq(dir, originPosition);
            while (targetPosition != Position.NOPOSITION) {
                if (targetPosition != Position.NOPOSITION) {
                    moves[count] = Move.valueOf(originPosition, originPiece, targetPosition, Piece.NONE);
                    count++;
                }
                targetPosition = Direction.getDirectMoveSq(dir, targetPosition);
            }
            // Copy to correctly sized array
            int [] ref_moves = Arrays.copyOf(moves, count);
            return_value[direction_index++] = ref_moves;
            QueenMove_Lut_Size += ref_moves.length;
        }
        return return_value;
    }
    
    static void king_generateMoves_White(IAddMoves ml, Board theBoard, int atSquare) {
        single_addMoves_White(ml, theBoard, WhiteKingMove_Lut[atSquare]);   
    }
    
    static void king_generateMoves_Black(IAddMoves ml, Board theBoard, int atSquare) {
        single_addMoves_Black(ml, theBoard, BlackKingMove_Lut[atSquare]);   
    }
    
    static void knight_generateMoves_White(IAddMoves ml, Board theBoard, int atSquare) {
        single_addMoves_White(ml, theBoard, WhiteKnightMove_Lut[atSquare]);
    }
    
    static void knight_generateMoves_Black(IAddMoves ml, Board theBoard, int atSquare) {
        single_addMoves_Black(ml, theBoard, BlackKnightMove_Lut[atSquare]);
    }
        
    static void king_generateMovesExtSearch_White(IAddMoves ml, Board theBoard, int atSquare) {
        single_addCaptures_White(ml, theBoard, WhiteKingMove_Lut[atSquare]);
    }
    
    static void king_generateMovesExtSearch_Black(IAddMoves ml, Board theBoard, int bitOffset) {
        single_addCaptures_Black(ml, theBoard, BlackKingMove_Lut[bitOffset]);
    }
        
    static void knight_generateMovesExtSearch_White(IAddMoves ml, Board theBoard, int bitOffset) {
        single_addCaptures_White(ml, theBoard, WhiteKnightMove_Lut[bitOffset]);
    }
    
    static void knight_generateMovesExtSearch_Black(IAddMoves ml, Board theBoard, int atSquare) {
        single_addCaptures_Black(ml, theBoard, BlackKnightMove_Lut[atSquare]);
    }
    
    static void rook_generateMoves_White(IAddMoves ml, Board theBoard, int atSquare) {
        multidirect_addMoves_White(ml, theBoard, WhiteRookMove_Lut[atSquare]);
    }
    
    static void rook_generateMoves_Black(IAddMoves ml, Board theBoard, int atSquare) {
        multidirect_addMoves_Black(ml, theBoard, BlackRookMove_Lut[atSquare]);
    }
    
    static void queen_generateMoves_White(IAddMoves ml, Board theBoard, int atSquare) {
        multidirect_addMoves_White(ml, theBoard, WhiteQueenMove_Lut[atSquare]); 
    }
    
    static void queen_generateMoves_Black(IAddMoves ml, Board theBoard, int atSquare) {
        multidirect_addMoves_Black(ml, theBoard, BlackQueenMove_Lut[atSquare]); 
    }
    
    static void bishop_generateMoves_White(IAddMoves ml, Board theBoard, int atSquare) {
        multidirect_addMoves_White(ml, theBoard, WhiteBishopMove_Lut[atSquare]);    
    }
    
    static void bishop_generateMoves_Black(IAddMoves ml, Board theBoard, int atSquare) {
        multidirect_addMoves_Black(ml, theBoard, BlackBishopMove_Lut[atSquare]);    
    }
        
    static void rook_generateMovesExtSearch_Black(IAddMoves ml, Board theBoard, int atSquare) {
        multidirect_addCapturesForBlack(ml, theBoard, BlackRookMove_Lut[atSquare]);
    }
    
    static void queen_generateMovesExtSearch_Black(IAddMoves ml, Board theBoard, int atSquare) {
        multidirect_addCapturesForBlack(ml, theBoard, BlackQueenMove_Lut[atSquare]);    
    }
    
    static void bishop_generateMovesExtSearch_Black(IAddMoves ml, Board theBoard, int atSquare) {
        multidirect_addCapturesForBlack(ml, theBoard, BlackBishopMove_Lut[atSquare]);   
    }
    
    static void rook_generateMovesExtSearch_White(IAddMoves ml, Board theBoard, int atSquare) {
        multidirect_addCapturesForWhite(ml, theBoard, WhiteRookMove_Lut[atSquare]);
    }
    
    static void queen_generateMovesExtSearch_White(IAddMoves ml, Board theBoard, int atSquare) {
        multidirect_addCapturesForWhite(ml, theBoard, WhiteQueenMove_Lut[atSquare]);    
    }
    
    static void bishop_generateMovesExtSearch_White(IAddMoves ml, Board theBoard, int atSquare) {
        multidirect_addCapturesForWhite(ml, theBoard, WhiteBishopMove_Lut[atSquare]);   
    }

    private static void multidirect_addMoves_White(IAddMoves ml, Board theBoard, int[][] moves) {
        for (int[] movesInDirection : moves) {
            for (int new_move : movesInDirection) {
                int targetPiece = theBoard.getPieceAtSquareEnemyBlack(1L << Move.getTargetPosition(new_move));
                switch(targetPiece) {
                case Piece.NONE:
                    ml.addNormal(new_move);
                    continue;
                case Piece.DONT_CARE:
                    break; // i.e. blocked by own piece
                default:
                    new_move = Move.setCapture(new_move, targetPiece);
                    ml.addPrio(new_move);
                    break;
                }
                break;
            }   
        }
    }
    
    private static void multidirect_addMoves_Black(IAddMoves ml, Board theBoard, int[][] moves) {
        for (int[] movesInDirection : moves) {
            for (int new_move : movesInDirection) {
                int targetPiece = theBoard.getPieceAtSquareEnemyWhite(1L << Move.getTargetPosition(new_move));
                switch(targetPiece) {
                case Piece.NONE:
                    ml.addNormal(new_move);
                    continue;
                case Piece.DONT_CARE:
                    break; // i.e. blocked by own piece
                default:
                    new_move = Move.setCapture(new_move, targetPiece);
                    ml.addPrio(new_move);
                    break;
                }
                break;
            }   
        }
    }
    
    private static void multidirect_addCapturesForBlack(IAddMoves ml, Board theBoard, int[][] moves) {
        for (int[] movesInDirection : moves) {
            for (int new_move : movesInDirection) {
                int targetPiece = theBoard.getPieceAtSquareEnemyWhite(1L << Move.getTargetPosition(new_move));
                switch(targetPiece) {
                case Piece.NONE:
                    continue;
                case Piece.DONT_CARE:
                    break; // i.e. blocked by own piece
                default:
                    new_move = Move.setCapture(new_move, targetPiece);
                    ml.addPrio(new_move);
                    break;
                }
                break;
            }
        }
    }
    
    private static void multidirect_addCapturesForWhite(IAddMoves ml, Board theBoard, int[][] moves) {
        for (int[] movesInDirection : moves) {
            for (int new_move : movesInDirection) {
                int targetPiece = theBoard.getPieceAtSquareEnemyBlack(1L << Move.getTargetPosition(new_move));
                switch(targetPiece) {
                case Piece.NONE:
                    continue;
                case Piece.DONT_CARE:
                    break; // i.e. blocked by own piece
                default:
                    new_move = Move.setCapture(new_move, targetPiece);
                    ml.addPrio(new_move);
                    break;
                }
                break;
            }
        }
    }
    
    private static void single_addMoves_White(IAddMoves ml, Board theBoard, int[] moves) {
        for (int new_move : moves) {
            int targetPiece = theBoard.getPieceAtSquareEnemyBlack(1L << Move.getTargetPosition(new_move));
            switch(targetPiece) {
            case Piece.NONE:
                ml.addNormal(new_move);
                continue;
            case Piece.DONT_CARE:
                break; // i.e. blocked by own piece
            default:
                new_move = Move.setCapture(new_move, targetPiece);
                ml.addPrio(new_move);
                break;
            }
        }
    }
    
    private static void single_addMoves_Black(IAddMoves ml, Board theBoard, int[] moves) {
        for (int new_move : moves) {
            int targetPiece = theBoard.getPieceAtSquareEnemyWhite(1L << Move.getTargetPosition(new_move));
            switch(targetPiece) {
            case Piece.NONE:
                ml.addNormal(new_move);
                continue;
            case Piece.DONT_CARE:
                break; // i.e. blocked by own piece
            default:
                new_move = Move.setCapture(new_move, targetPiece);
                ml.addPrio(new_move);
                break;
            }
        }
    }
    
    private static void single_addCaptures_White(IAddMoves ml, Board theBoard, int[] moves) {
        for (int new_move : moves) {
            int targetPiece = theBoard.getPieceAtSquareEnemyBlack(1L << Move.getTargetPosition(new_move));
            switch(targetPiece) {
            case Piece.NONE:
                continue;
            case Piece.DONT_CARE:
                break; // i.e. blocked by own piece
            default:
                new_move = Move.setCapture(new_move, targetPiece);
                ml.addPrio(new_move);
                break;
            }
        }
    }
    
    private static void single_addCaptures_Black(IAddMoves ml, Board theBoard, int[] moves) {
        for (int new_move : moves) {
            int targetPiece = theBoard.getPieceAtSquareEnemyWhite(1L << Move.getTargetPosition(new_move));
            switch(targetPiece) {
            case Piece.NONE:
                continue;
            case Piece.DONT_CARE:
                break; // i.e. blocked by own piece
            default:
                new_move = Move.setCapture(new_move, targetPiece);
                ml.addPrio(new_move);
                break;
            }
        }
    }
    
    private static int pawn_genOneSqTargetWhite(int bitOffset) {
        return bitOffset+8;
    }
    private static int pawn_genOneSqTargetBlack(int bitOffset) {
        return bitOffset-8;
    }   
    
    private static int pawn_genTwoSqTargetWhite(int bitOffset) {
        int moveTo = Position.NOPOSITION;
        if (BitBoard.getRank(bitOffset) == IntRank.R2) {
            // bound checking is implicit from start position check
            moveTo = bitOffset+16;
        }
        return moveTo;
    }
    
    private static int pawn_genTwoSqTargetBlack(int bitOffset) {
        int moveTo = Position.NOPOSITION;
        if (BitBoard.getRank(bitOffset) == IntRank.R7) {
            // bound checking is implicit from start position check
            moveTo = bitOffset-16;
        }
        return moveTo;
    }
    
    static long pawn_genLeftCaptureTargetWhite(int bitOffset) {
        return BitBoard.generatePawnCaptureTargetBoardUpLeft(bitOffset);
    }
    
    static long pawn_genRightCaptureTargetWhite(int bitOffset) {
        return BitBoard.generatePawnCaptureTargetBoardUpRight(bitOffset);
    }
    
    private static int pawn_isCapturableWhite(Board theBoard, long captureMask) {
        int capturePiece = Piece.NONE;
        int queryPiece = theBoard.getPieceAtSquareEnemyBlack(captureMask);
        if (queryPiece != Piece.NONE && queryPiece != Piece.DONT_CARE) {
            capturePiece = queryPiece;
        }
        return capturePiece;
    }
    
    private static boolean pawn_checkPromotionPossibleWhite(int targetBitOffset) {
        return BitBoard.getRank(targetBitOffset) == IntRank.R8;
    }
    
    private static void pawn_checkPromotionAddMoveWhite(int originBitOffset, IAddMoves ml, int targetBitOffset) {
        if (pawn_checkPromotionPossibleWhite(targetBitOffset)) {
            ml.addPrio(WhitePawnPromotionMove_Lut[originBitOffset][0]);
        } else {
            ml.addNormal(Move.valueOfBit(originBitOffset, Piece.WHITE_PAWN, targetBitOffset, Piece.NONE));
        }
    }
    
    private static void pawn_checkPromotionAddCaptureMoveWhite(int ownPiece, int originBitOffset, IAddMoves ml, int targetBitOffset, int targetPiece) {
        if (pawn_checkPromotionPossibleWhite(targetBitOffset)) {
            ml.addPrio(Move.valueOfBit(Move.TYPE_PROMOTION_MASK, originBitOffset, ownPiece, targetBitOffset, targetPiece, Piece.QUEEN ));
        } else {
            ml.addPrio(Move.valueOfBit(originBitOffset, ownPiece, targetBitOffset, targetPiece));
        }
    }
    
    static long pawn_genLeftCaptureTargetBlack(int bitOffset) {
        return BitBoard.generatePawnCaptureTargetBoardDownRight(bitOffset);
    }
    
    static long pawn_genRightCaptureTargetBlack(int bitOffset) {
        return BitBoard.generatePawnCaptureTargetBoardDownLeft(bitOffset);
    }
    
    private static int pawn_isCapturableBlack(Board theBoard, long captureMask) {
        int capturePiece = Piece.NONE;
        int queryPiece = theBoard.getPieceAtSquareEnemyWhite(captureMask);
        if (queryPiece != Piece.NONE && queryPiece != Piece.DONT_CARE) {
            capturePiece = queryPiece;
        }
        return capturePiece;
    }
    
    private static boolean pawn_checkPromotionPossibleBlack(int targetBitOffset ) {
        return BitBoard.getRank(targetBitOffset) == IntRank.R1;
    }
    
    private static void pawn_checkPromotionAddMoveBlack(int originBitOffset, IAddMoves ml, int targetBitOffset) {
        if (pawn_checkPromotionPossibleBlack(targetBitOffset)) {
            ml.addPrio(BlackPawnPromotionMove_Lut[originBitOffset][0]);
        } else {
            ml.addNormal(Move.valueOfBit(originBitOffset, Piece.BLACK_PAWN, targetBitOffset, Piece.NONE));
        }
    }
    
    private static void pawn_checkPromotionAddCaptureMoveBlack(int ownPiece, int originBitOffset, IAddMoves ml,
            int targetBitOffset, int targetPiece) {
        if (pawn_checkPromotionPossibleBlack(targetBitOffset)) {
            ml.addPrio(Move.valueOfBit(Move.TYPE_PROMOTION_MASK, originBitOffset, ownPiece, targetBitOffset, targetPiece, Piece.QUEEN ));
        } else {
            ml.addPrio(Move.valueOfBit(originBitOffset, ownPiece, targetBitOffset, targetPiece));
        }
    }
    
    static void pawn_generateMoves_White(IAddMoves ml, Board theBoard, int bitOffset) {
        int ownPiece = Piece.WHITE_PAWN;
        int capturePiece = Piece.NONE;
        // Check for standard one and two square moves
        int targetBitOffset = pawn_genOneSqTargetWhite(bitOffset);
        if (theBoard.squareIsEmpty(targetBitOffset)) {
            pawn_checkPromotionAddMoveWhite(bitOffset, ml, targetBitOffset);
            targetBitOffset = pawn_genTwoSqTargetWhite(bitOffset);
            if (targetBitOffset != Position.NOPOSITION && theBoard.squareIsEmpty(targetBitOffset)) {
                // Can't be a promotion or capture
                ml.addNormal(Move.valueOfBit(bitOffset, ownPiece, targetBitOffset , Piece.NONE));
            }   
        }
        // Check for capture moves, includes en passant
        int captureOffset = whitePawnLeftAttacksAsOffset_Lut[bitOffset];
        if (captureOffset != Position.NOPOSITION) {
            long captureMask = 1L << captureOffset;
            capturePiece = pawn_isCapturableWhite(theBoard, captureMask);
            if (capturePiece != Piece.NONE) {
                pawn_checkPromotionAddCaptureMoveWhite(ownPiece, bitOffset, ml, captureOffset, capturePiece);
            } else {
                int enPassant = theBoard.getEnPassantTargetSq();
                if (enPassant != BitBoard.INVALID && captureMask == (1L << enPassant)) {
                    capturePiece = Piece.BLACK_PAWN;
                    // promotion can't be possible if en passant capture
                    ml.addPrio(Move.valueOfEnPassantBit(0, bitOffset, ownPiece, captureOffset, capturePiece, Piece.NONE));
                }
            }
        }
        captureOffset = whitePawnRightAttacksAsOffset_Lut[bitOffset];
        if (captureOffset != Position.NOPOSITION) {
            long captureMask = 1L << captureOffset;
            capturePiece = pawn_isCapturableWhite(theBoard, captureMask);
            if (capturePiece != Piece.NONE) {
                pawn_checkPromotionAddCaptureMoveWhite(ownPiece, bitOffset, ml, captureOffset, capturePiece);
            } else {
                int enPassant = theBoard.getEnPassantTargetSq();
                if (enPassant != BitBoard.INVALID && captureMask == (1L << enPassant)) {
                    capturePiece = Piece.BLACK_PAWN;
                    // promotion can't be possible if en passant capture
                    ml.addPrio(Move.valueOfEnPassantBit(0, bitOffset, ownPiece, captureOffset, capturePiece, Piece.NONE));
                }
            }
        }
    }
    
    static void pawn_generateMoves_Black(IAddMoves ml, Board theBoard, int bitOffset) {
        int ownPiece = Piece.BLACK_PAWN;
        int capturePiece = Piece.NONE;
        // Check for standard one and two square moves
        int targetBitOffset = pawn_genOneSqTargetBlack(bitOffset);
        if (theBoard.squareIsEmpty(targetBitOffset)) {
            pawn_checkPromotionAddMoveBlack(bitOffset, ml, targetBitOffset);
            targetBitOffset = pawn_genTwoSqTargetBlack(bitOffset);
            if (targetBitOffset != Position.NOPOSITION && theBoard.squareIsEmpty(targetBitOffset)) {
                // Can't be a promotion or capture
                ml.addNormal(Move.valueOfBit(bitOffset, ownPiece, targetBitOffset , Piece.NONE));
            }   
        }
        // Check for capture moves, includes en passant
        int captureOffset = blackPawnLeftAttacksAsOffset_Lut[bitOffset];
        if (captureOffset != Position.NOPOSITION) {
            long captureMask = 1L << captureOffset;
            capturePiece = pawn_isCapturableBlack(theBoard, captureMask);
            if (capturePiece != Piece.NONE) {
                pawn_checkPromotionAddCaptureMoveBlack(ownPiece, bitOffset, ml, captureOffset, capturePiece);
            } else {
                int enPassant = theBoard.getEnPassantTargetSq();
                if (enPassant != BitBoard.INVALID && captureMask == (1L << enPassant)) {
                    capturePiece = Piece.WHITE_PAWN;
                    // promotion can't be possible if en passant capture
                    ml.addPrio(Move.valueOfEnPassantBit(0, bitOffset, ownPiece, captureOffset, capturePiece, Piece.NONE));
                }
            }
        }
        captureOffset = blackPawnRightAttacksAsOffset_Lut[bitOffset];
        if (captureOffset != Position.NOPOSITION) {
            long captureMask = 1L << captureOffset;
            capturePiece = pawn_isCapturableBlack(theBoard, captureMask);
            if (capturePiece != Piece.NONE) {
                pawn_checkPromotionAddCaptureMoveBlack(ownPiece, bitOffset, ml, captureOffset, capturePiece);
            } else {
                int enPassant = theBoard.getEnPassantTargetSq();
                if (enPassant != BitBoard.INVALID && captureMask == (1L << enPassant)) {
                    capturePiece = Piece.WHITE_PAWN;
                    // promotion can't be possible if en passant capture
                    ml.addPrio(Move.valueOfEnPassantBit(0, bitOffset, ownPiece, captureOffset, capturePiece, Piece.NONE));
                }
            }
        }
    }
    
    static void pawn_generateMovesForExtendedSearch_White(IAddMoves ml, Board theBoard, int bitOffset) {
        // Standard move
        int targetOffset = pawn_genOneSqTargetWhite(bitOffset);
        if (pawn_checkPromotionPossibleWhite(targetOffset) && theBoard.squareIsEmpty(targetOffset)) {
            ml.addPrio(WhitePawnPromotionMove_Lut[bitOffset][0]);
        }
        // Capture moves
        int ownPiece = Piece.WHITE_PAWN;
        int capturePiece = Piece.NONE;
        int captureOffset = whitePawnLeftAttacksAsOffset_Lut[bitOffset];
        if (captureOffset != Position.NOPOSITION) {
            long captureMask = 1L << captureOffset;
            capturePiece = pawn_isCapturableWhite(theBoard, captureMask);
            if (capturePiece != Piece.NONE) {
                pawn_checkPromotionAddCaptureMoveWhite(ownPiece, bitOffset, ml, captureOffset, capturePiece);
            } else {
                int enPassant = theBoard.getEnPassantTargetSq();
                if (enPassant != BitBoard.INVALID && captureMask == (1L << enPassant)) {
                    capturePiece = Piece.BLACK_PAWN;
                    // promotion can't be possible if en passant capture
                    ml.addPrio(Move.valueOfEnPassantBit(0, bitOffset, ownPiece, captureOffset, capturePiece, Piece.NONE));
                }
            }
        }
        captureOffset = whitePawnRightAttacksAsOffset_Lut[bitOffset];
        if (captureOffset != Position.NOPOSITION) {
            long captureMask = 1L << captureOffset;
            capturePiece = pawn_isCapturableWhite(theBoard, captureMask);
            if (capturePiece != Piece.NONE) {
                pawn_checkPromotionAddCaptureMoveWhite(ownPiece, bitOffset, ml, captureOffset, capturePiece);
            } else {
                int enPassant = theBoard.getEnPassantTargetSq();
                if (enPassant != BitBoard.INVALID && captureMask == (1L << enPassant)) {
                    capturePiece = Piece.BLACK_PAWN;
                    // promotion can't be possible if en passant capture
                    ml.addPrio(Move.valueOfEnPassantBit(0, bitOffset, ownPiece, captureOffset, capturePiece, Piece.NONE));
                }
            }
        }
    }
    
    static void pawn_generateMovesForExtendedSearch_Black(IAddMoves ml, Board theBoard, int bitOffset) {
        // Standard move
        int targetOffset = pawn_genOneSqTargetBlack(bitOffset);
        if (pawn_checkPromotionPossibleBlack(targetOffset) && theBoard.squareIsEmpty(targetOffset)) {
            ml.addPrio(BlackPawnPromotionMove_Lut[bitOffset][0]);
        }
        // Capture moves
        int ownPiece = Piece.BLACK_PAWN;
        int capturePiece = Piece.NONE;
        int captureOffset = blackPawnLeftAttacksAsOffset_Lut[bitOffset];
        if (captureOffset != Position.NOPOSITION) {
            long captureMask = 1L << captureOffset;
            capturePiece = pawn_isCapturableBlack(theBoard, captureMask);
            if (capturePiece != Piece.NONE) {
                pawn_checkPromotionAddCaptureMoveBlack(ownPiece, bitOffset, ml, captureOffset, capturePiece);
            } else {
                int enPassant = theBoard.getEnPassantTargetSq();
                if (enPassant != BitBoard.INVALID && captureMask == (1L << enPassant)) {
                    capturePiece = Piece.WHITE_PAWN;
                    // promotion can't be possible if en passant capture
                    ml.addPrio(Move.valueOfEnPassantBit(0, bitOffset, ownPiece, captureOffset, capturePiece, Piece.NONE));
                }
            }
        }
        captureOffset = blackPawnRightAttacksAsOffset_Lut[bitOffset];
        if (captureOffset != Position.NOPOSITION) {
            long captureMask = 1L << captureOffset;
            capturePiece = pawn_isCapturableBlack(theBoard, captureMask);
            if (capturePiece != Piece.NONE) {
                pawn_checkPromotionAddCaptureMoveBlack(ownPiece, bitOffset, ml, captureOffset, capturePiece);
            } else {
                int enPassant = theBoard.getEnPassantTargetSq();
                if (enPassant != BitBoard.INVALID && captureMask == (1L << enPassant)) {
                    capturePiece = Piece.WHITE_PAWN;
                    // promotion can't be possible if en passant capture
                    ml.addPrio(Move.valueOfEnPassantBit(0, bitOffset, ownPiece, captureOffset, capturePiece, Piece.NONE));
                }
            }
        }
    }
    
    static void pawn_generatePromotionMoves_White(IAddMoves ml, Board theBoard, int bitOffset) {
        // Standard move
        int targetOffset = pawn_genOneSqTargetWhite(bitOffset);
        if (pawn_checkPromotionPossibleWhite(targetOffset) && theBoard.squareIsEmpty(targetOffset)) {
            ml.addPrio(WhitePawnPromotionMove_Lut[bitOffset][0]);
        }
        // Capture moves
        int ownPiece = Piece.WHITE_PAWN;
        int capturePiece = Piece.NONE;
        int captureOffset = whitePawnLeftAttacksAsOffset_Lut[bitOffset];
        if (captureOffset != Position.NOPOSITION) {
            capturePiece = pawn_isCapturableWhite(theBoard, 1L << captureOffset);
            if (capturePiece != Piece.NONE) {
                ml.addPrio(Move.valueOfBit(Move.TYPE_PROMOTION_MASK, bitOffset, ownPiece, captureOffset, capturePiece, Piece.QUEEN));
            }
        }
        captureOffset = whitePawnRightAttacksAsOffset_Lut[bitOffset];
        if (captureOffset != Position.NOPOSITION) {
            capturePiece = pawn_isCapturableWhite(theBoard, 1L << captureOffset);
            if (capturePiece != Piece.NONE) {
                ml.addPrio(Move.valueOfBit(Move.TYPE_PROMOTION_MASK, bitOffset, ownPiece, captureOffset, capturePiece, Piece.QUEEN));
            }
        }
    }
    
    static void pawn_generatePromotionMoves_Black(IAddMoves ml, Board theBoard, int bitOffset) {
        // Standard move
        int targetOffset = pawn_genOneSqTargetBlack(bitOffset);
        if (pawn_checkPromotionPossibleBlack(targetOffset) && theBoard.squareIsEmpty(targetOffset)) {
            ml.addPrio(BlackPawnPromotionMove_Lut[bitOffset][0]);
        }
        // Capture moves
        int ownPiece = Piece.BLACK_PAWN;
        int capturePiece = Piece.NONE;
        int captureOffset = blackPawnLeftAttacksAsOffset_Lut[bitOffset];
        if (captureOffset != Position.NOPOSITION) {
            capturePiece = pawn_isCapturableBlack(theBoard, 1L << captureOffset);
            if (capturePiece != Piece.NONE) {
                ml.addPrio(Move.valueOfBit(Move.TYPE_PROMOTION_MASK, bitOffset, ownPiece, captureOffset, capturePiece, Piece.QUEEN));
            }
        }
        captureOffset = blackPawnRightAttacksAsOffset_Lut[bitOffset];
        if (captureOffset != Position.NOPOSITION) {
            capturePiece = pawn_isCapturableBlack(theBoard, 1L << captureOffset);
            if (capturePiece != Piece.NONE) {
                ml.addPrio(Move.valueOfBit(Move.TYPE_PROMOTION_MASK, bitOffset, ownPiece, captureOffset, capturePiece, Piece.QUEEN));
            }
        }
    }
    
    /* 1-dimensional array:
     * 1st index is a position integer, this is the origin square
     * indexes a bit mask of the squares that the origin square can attack by a White Pawn capture */
    public static final int[] whitePawnLeftAttacksAsOffset_Lut = new int[64];
    static {
        int bitOffset = 0;
        for (int square : Position.values) {
            whitePawnLeftAttacksAsOffset_Lut[bitOffset++] = createWhitePawnLeftCaptureMovesFromSq(square);
        }
    }
    static int createWhitePawnLeftCaptureMovesFromSq(int atPos) {
        int targetOffset = Position.NOPOSITION;
        if (Position.getRank(atPos) != 0) {
            int targetPosition = Direction.getDirectMoveSq(Direction.upLeft, atPos);
            if (targetPosition != Position.NOPOSITION) {
                targetOffset = BitBoard.positionToBit_Lut[targetPosition];
            }
        }
        return targetOffset;
    }
    
    /* 1-dimensional array:
     * 1st index is a position integer, this is the origin square
     * indexes a bit mask of the squares that the origin square can attack by a White Pawn capture */
    public static final int[] whitePawnRightAttacksAsOffset_Lut = new int[64];
    static {
        int bitOffset = 0;
        for (int square : Position.values) {
            whitePawnRightAttacksAsOffset_Lut[bitOffset++] = createWhitePawnRightCaptureMovesFromSq(square);
        }
    }
    static int createWhitePawnRightCaptureMovesFromSq(int atPos) {
        int targetOffset = Position.NOPOSITION;
        if (Position.getRank(atPos) != 0) {
            int targetPosition = Direction.getDirectMoveSq(Direction.upRight, atPos);
            if (targetPosition != Position.NOPOSITION) {
                targetOffset = BitBoard.positionToBit_Lut[targetPosition];
            }
        }
        return targetOffset;
    }
    
    /* 1-dimensional array:
     * 1st index is a position integer, this is the origin square
     * indexes a bit mask of the squares that the origin square can attack by a White Pawn capture */
    public static final int[] blackPawnLeftAttacksAsOffset_Lut = new int[64];
    static {
        int bitOffset = 0;
        for (int square : Position.values) {
            blackPawnLeftAttacksAsOffset_Lut[bitOffset++] = createBlackPawnLeftCaptureMovesFromSq(square);
        }
    }
    static int createBlackPawnLeftCaptureMovesFromSq(int atPos) {
        int targetOffset = Position.NOPOSITION;
        if (Position.getRank(atPos) != 7) {
            int targetPosition = Direction.getDirectMoveSq(Direction.downRight, atPos);
            if (targetPosition != Position.NOPOSITION) {
                targetOffset = BitBoard.positionToBit_Lut[targetPosition];
            }
        }
        return targetOffset;
    }
    
    /* 1-dimensional array:
     * 1st index is a position integer, this is the origin square
     * indexes a bit mask of the squares that the origin square can attack by a White Pawn capture */
    public static final int[] blackPawnRightAttacksAsOffset_Lut = new int[64];
    static {
        int bitOffset = 0;
        for (int square : Position.values) {
            blackPawnRightAttacksAsOffset_Lut[bitOffset++] = createblackPawnRightCaptureMovesFromSq(square);
        }
    }
    static int createblackPawnRightCaptureMovesFromSq(int atPos) {
        int targetOffset = Position.NOPOSITION;
        if (Position.getRank(atPos) != 7) {
            int targetPosition = Direction.getDirectMoveSq(Direction.downLeft, atPos);
            if (targetPosition != Position.NOPOSITION) {
                targetOffset = BitBoard.positionToBit_Lut[targetPosition];
            }
        }
        return targetOffset;
    }
    
    static int [] createCombinedTable(byte [] mg_table, byte[] eg_table) {
    	int [] combined_table = new int [64];
    	for (int i=0; i < 64; i++) {
    		int mg = mg_table[i];
    		int eg = eg_table[i];
    		combined_table[i] = mg;
    		combined_table[i] &= 0x0000_FFFF;
    		combined_table[i] |= (eg << 16);
    	}
    	return combined_table;
    }
    
    public static final int [][] COMBINED_PIECE_SQUARE_TABLES;
    static {
    	COMBINED_PIECE_SQUARE_TABLES = new int[15][64];
        
    	COMBINED_PIECE_SQUARE_TABLES[Piece.WHITE_PAWN] = createCombinedTable(PAWN_WHITE_WEIGHTINGS, PAWN_WHITE_ENDGAME_WEIGHTINGS);
    	COMBINED_PIECE_SQUARE_TABLES[Piece.WHITE_KING] = createCombinedTable(KING_WHITE_MIDGAME_WEIGHTINGS, KING_WHITE_ENDGAME_WEIGHTINGS);
    	COMBINED_PIECE_SQUARE_TABLES[Piece.WHITE_QUEEN] = createCombinedTable(ZERO_WEIGHTING, ZERO_WEIGHTING);
    	COMBINED_PIECE_SQUARE_TABLES[Piece.WHITE_ROOK] = createCombinedTable(ROOK_WHITE_WEIGHTINGS, ZERO_WEIGHTING);
    	COMBINED_PIECE_SQUARE_TABLES[Piece.WHITE_BISHOP] = createCombinedTable(ZERO_WEIGHTING, ZERO_WEIGHTING);
    	COMBINED_PIECE_SQUARE_TABLES[Piece.WHITE_KNIGHT] = createCombinedTable(KNIGHT_WHITE_WEIGHTINGS, KNIGHT_WHITE_WEIGHTINGS);
        
    	COMBINED_PIECE_SQUARE_TABLES[Piece.BLACK_PAWN] = createCombinedTable(PAWN_BLACK_WEIGHTINGS, PAWN_BLACK_ENDGAME_WEIGHTINGS);
    	COMBINED_PIECE_SQUARE_TABLES[Piece.BLACK_KING] = createCombinedTable(KING_BLACK_MIDGAME_WEIGHTINGS, KING_BLACK_ENDGAME_WEIGHTINGS);
    	COMBINED_PIECE_SQUARE_TABLES[Piece.BLACK_QUEEN] = createCombinedTable(ZERO_WEIGHTING, ZERO_WEIGHTING);
    	COMBINED_PIECE_SQUARE_TABLES[Piece.BLACK_ROOK] = createCombinedTable(ROOK_BLACK_WEIGHTINGS, ZERO_WEIGHTING);
    	COMBINED_PIECE_SQUARE_TABLES[Piece.BLACK_BISHOP] = createCombinedTable(ZERO_WEIGHTING, ZERO_WEIGHTING);
    	COMBINED_PIECE_SQUARE_TABLES[Piece.BLACK_KNIGHT] = createCombinedTable(KNIGHT_BLACK_WEIGHTINGS, KNIGHT_BLACK_WEIGHTINGS);
    }
}
